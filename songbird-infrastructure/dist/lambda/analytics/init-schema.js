"use strict";
/**
 * Aurora Analytics Schema Initialization
 *
 * Creates the analytics schema with partitioned tables for telemetry, locations, and journeys.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.handler = void 0;
const client_rds_data_1 = require("@aws-sdk/client-rds-data");
const rds = new client_rds_data_1.RDSDataClient({});
const CLUSTER_ARN = process.env.CLUSTER_ARN;
const SECRET_ARN = process.env.SECRET_ARN;
const DATABASE_NAME = process.env.DATABASE_NAME;
const SCHEMA_SQL = `
-- Create analytics schema
CREATE SCHEMA IF NOT EXISTS analytics;

-- Devices table (no partitioning needed)
CREATE TABLE IF NOT EXISTS analytics.devices (
  serial_number VARCHAR(100) PRIMARY KEY,
  device_uid VARCHAR(100),
  name VARCHAR(255),
  fleet_name VARCHAR(255),
  fleet_uid VARCHAR(100),
  product_uid VARCHAR(100),
  last_seen BIGINT,
  last_location_lat DOUBLE PRECISION,
  last_location_lon DOUBLE PRECISION,
  status VARCHAR(50),
  voltage DOUBLE PRECISION,
  temperature DOUBLE PRECISION,
  created_at BIGINT,
  updated_at BIGINT
);

CREATE INDEX IF NOT EXISTS idx_devices_fleet ON analytics.devices(fleet_uid);
CREATE INDEX IF NOT EXISTS idx_devices_status ON analytics.devices(status);
CREATE INDEX IF NOT EXISTS idx_devices_last_seen ON analytics.devices(last_seen DESC);

-- Telemetry table (partitioned by time)
CREATE TABLE IF NOT EXISTS analytics.telemetry (
  device_uid VARCHAR(100),
  serial_number VARCHAR(100),
  time TIMESTAMP WITH TIME ZONE,
  temperature DOUBLE PRECISION,
  humidity DOUBLE PRECISION,
  pressure DOUBLE PRECISION,
  voltage DOUBLE PRECISION,
  event_type VARCHAR(100),
  PRIMARY KEY (serial_number, time)
) PARTITION BY RANGE (time);

-- Create partitions for telemetry (last 6 months + next 6 months)
CREATE TABLE IF NOT EXISTS analytics.telemetry_2024_q4
  PARTITION OF analytics.telemetry
  FOR VALUES FROM ('2024-10-01') TO ('2025-01-01');

CREATE TABLE IF NOT EXISTS analytics.telemetry_2025_q1
  PARTITION OF analytics.telemetry
  FOR VALUES FROM ('2025-01-01') TO ('2025-04-01');

CREATE TABLE IF NOT EXISTS analytics.telemetry_2025_q2
  PARTITION OF analytics.telemetry
  FOR VALUES FROM ('2025-04-01') TO ('2025-07-01');

CREATE TABLE IF NOT EXISTS analytics.telemetry_2025_q3
  PARTITION OF analytics.telemetry
  FOR VALUES FROM ('2025-07-01') TO ('2025-10-01');

CREATE TABLE IF NOT EXISTS analytics.telemetry_2025_q4
  PARTITION OF analytics.telemetry
  FOR VALUES FROM ('2025-10-01') TO ('2026-01-01');

CREATE TABLE IF NOT EXISTS analytics.telemetry_2026_q1
  PARTITION OF analytics.telemetry
  FOR VALUES FROM ('2026-01-01') TO ('2026-04-01');

CREATE TABLE IF NOT EXISTS analytics.telemetry_2026_q2
  PARTITION OF analytics.telemetry
  FOR VALUES FROM ('2026-04-01') TO ('2026-07-01');

CREATE INDEX IF NOT EXISTS idx_telemetry_device_time ON analytics.telemetry(serial_number, time DESC);
CREATE INDEX IF NOT EXISTS idx_telemetry_event_type ON analytics.telemetry(event_type, time DESC);

-- Locations table (partitioned by time)
CREATE TABLE IF NOT EXISTS analytics.locations (
  device_uid VARCHAR(100),
  serial_number VARCHAR(100),
  time TIMESTAMP WITH TIME ZONE,
  lat DOUBLE PRECISION,
  lon DOUBLE PRECISION,
  source VARCHAR(50),
  journey_id BIGINT,
  PRIMARY KEY (serial_number, time)
) PARTITION BY RANGE (time);

-- Create partitions for locations
CREATE TABLE IF NOT EXISTS analytics.locations_2024_q4
  PARTITION OF analytics.locations
  FOR VALUES FROM ('2024-10-01') TO ('2025-01-01');

CREATE TABLE IF NOT EXISTS analytics.locations_2025_q1
  PARTITION OF analytics.locations
  FOR VALUES FROM ('2025-01-01') TO ('2025-04-01');

CREATE TABLE IF NOT EXISTS analytics.locations_2025_q2
  PARTITION OF analytics.locations
  FOR VALUES FROM ('2025-04-01') TO ('2025-07-01');

CREATE TABLE IF NOT EXISTS analytics.locations_2025_q3
  PARTITION OF analytics.locations
  FOR VALUES FROM ('2025-07-01') TO ('2025-10-01');

CREATE TABLE IF NOT EXISTS analytics.locations_2025_q4
  PARTITION OF analytics.locations
  FOR VALUES FROM ('2025-10-01') TO ('2026-01-01');

CREATE TABLE IF NOT EXISTS analytics.locations_2026_q1
  PARTITION OF analytics.locations
  FOR VALUES FROM ('2026-01-01') TO ('2026-04-01');

CREATE TABLE IF NOT EXISTS analytics.locations_2026_q2
  PARTITION OF analytics.locations
  FOR VALUES FROM ('2026-04-01') TO ('2026-07-01');

CREATE INDEX IF NOT EXISTS idx_locations_device_time ON analytics.locations(serial_number, time DESC);
CREATE INDEX IF NOT EXISTS idx_locations_journey ON analytics.locations(serial_number, journey_id);

-- Alerts table (no partitioning for now - less data)
CREATE TABLE IF NOT EXISTS analytics.alerts (
  alert_id VARCHAR(100) PRIMARY KEY,
  device_uid VARCHAR(100),
  serial_number VARCHAR(100),
  alert_type VARCHAR(100),
  severity VARCHAR(50),
  message TEXT,
  acknowledged BOOLEAN,
  created_at BIGINT,
  acknowledged_at BIGINT,
  acknowledged_by VARCHAR(255)
);

CREATE INDEX IF NOT EXISTS idx_alerts_device ON analytics.alerts(serial_number, created_at DESC);
CREATE INDEX IF NOT EXISTS idx_alerts_status ON analytics.alerts(acknowledged, created_at DESC);

-- Journeys table (no partitioning for now)
CREATE TABLE IF NOT EXISTS analytics.journeys (
  device_uid VARCHAR(100),
  serial_number VARCHAR(100),
  journey_id BIGINT,
  start_time BIGINT,
  end_time BIGINT,
  status VARCHAR(50),
  distance_km DOUBLE PRECISION,
  PRIMARY KEY (serial_number, journey_id)
);

CREATE INDEX IF NOT EXISTS idx_journeys_status ON analytics.journeys(status, start_time DESC);
CREATE INDEX IF NOT EXISTS idx_journeys_device_time ON analytics.journeys(serial_number, start_time DESC);

-- Materialized view for device stats (for faster queries)
CREATE MATERIALIZED VIEW IF NOT EXISTS analytics.device_stats AS
SELECT
  d.serial_number,
  d.name,
  d.fleet_name,
  d.status,
  d.last_seen,
  COUNT(DISTINCT t.time) as telemetry_count,
  COUNT(DISTINCT a.alert_id) as alert_count,
  MAX(t.temperature) as max_temp,
  MIN(t.temperature) as min_temp,
  AVG(t.temperature) as avg_temp
FROM analytics.devices d
LEFT JOIN analytics.telemetry t ON d.serial_number = t.serial_number
  AND t.time > NOW() - INTERVAL '30 days'
LEFT JOIN analytics.alerts a ON d.serial_number = a.serial_number
  AND a.created_at > EXTRACT(EPOCH FROM NOW() - INTERVAL '30 days')
GROUP BY d.serial_number, d.name, d.fleet_name, d.status, d.last_seen;

-- Grant permissions
GRANT USAGE ON SCHEMA analytics TO PUBLIC;
GRANT SELECT ON ALL TABLES IN SCHEMA analytics TO PUBLIC;
`;
const handler = async () => {
    try {
        console.log('Initializing Aurora analytics schema...');
        // Split SQL into individual statements and remove comment-only lines
        const statements = SCHEMA_SQL
            .split(';')
            .map(s => s.trim())
            .filter(s => s.length > 0)
            .map(s => {
            // Remove comment lines from the start of each statement
            const lines = s.split('\n');
            const nonCommentLines = lines.filter(line => !line.trim().startsWith('--'));
            return nonCommentLines.join('\n').trim();
        })
            .filter(s => s.length > 0);
        // Execute each statement
        for (const sql of statements) {
            try {
                await rds.send(new client_rds_data_1.ExecuteStatementCommand({
                    resourceArn: CLUSTER_ARN,
                    secretArn: SECRET_ARN,
                    database: DATABASE_NAME,
                    sql,
                }));
                console.log(`Executed: ${sql.substring(0, 50)}...`);
            }
            catch (error) {
                // Ignore "already exists" errors
                if (error.message?.includes('already exists')) {
                    console.log(`Skipped (already exists): ${sql.substring(0, 50)}...`);
                }
                else {
                    throw error;
                }
            }
        }
        console.log('Schema initialization complete');
        return {
            statusCode: 200,
            body: JSON.stringify({
                message: 'Analytics schema initialized successfully',
            }),
        };
    }
    catch (error) {
        console.error('Schema initialization failed:', error);
        throw error;
    }
};
exports.handler = handler;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5pdC1zY2hlbWEuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi9sYW1iZGEvYW5hbHl0aWNzL2luaXQtc2NoZW1hLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQTs7OztHQUlHOzs7QUFFSCw4REFBZ0g7QUFFaEgsTUFBTSxHQUFHLEdBQUcsSUFBSSwrQkFBYSxDQUFDLEVBQUUsQ0FBQyxDQUFDO0FBRWxDLE1BQU0sV0FBVyxHQUFHLE9BQU8sQ0FBQyxHQUFHLENBQUMsV0FBWSxDQUFDO0FBQzdDLE1BQU0sVUFBVSxHQUFHLE9BQU8sQ0FBQyxHQUFHLENBQUMsVUFBVyxDQUFDO0FBQzNDLE1BQU0sYUFBYSxHQUFHLE9BQU8sQ0FBQyxHQUFHLENBQUMsYUFBYyxDQUFDO0FBRWpELE1BQU0sVUFBVSxHQUFHOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQTBLbEIsQ0FBQztBQUVLLE1BQU0sT0FBTyxHQUFHLEtBQUssSUFBa0IsRUFBRTtJQUM5QyxJQUFJLENBQUM7UUFDSCxPQUFPLENBQUMsR0FBRyxDQUFDLHlDQUF5QyxDQUFDLENBQUM7UUFFdkQscUVBQXFFO1FBQ3JFLE1BQU0sVUFBVSxHQUFHLFVBQVU7YUFDMUIsS0FBSyxDQUFDLEdBQUcsQ0FBQzthQUNWLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxJQUFJLEVBQUUsQ0FBQzthQUNsQixNQUFNLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQzthQUN6QixHQUFHLENBQUMsQ0FBQyxDQUFDLEVBQUU7WUFDUCx3REFBd0Q7WUFDeEQsTUFBTSxLQUFLLEdBQUcsQ0FBQyxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsQ0FBQztZQUM1QixNQUFNLGVBQWUsR0FBRyxLQUFLLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFFLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUM7WUFDNUUsT0FBTyxlQUFlLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLElBQUksRUFBRSxDQUFDO1FBQzNDLENBQUMsQ0FBQzthQUNELE1BQU0sQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxDQUFDLENBQUM7UUFFN0IseUJBQXlCO1FBQ3pCLEtBQUssTUFBTSxHQUFHLElBQUksVUFBVSxFQUFFLENBQUM7WUFDN0IsSUFBSSxDQUFDO2dCQUNILE1BQU0sR0FBRyxDQUFDLElBQUksQ0FBQyxJQUFJLHlDQUF1QixDQUFDO29CQUN6QyxXQUFXLEVBQUUsV0FBVztvQkFDeEIsU0FBUyxFQUFFLFVBQVU7b0JBQ3JCLFFBQVEsRUFBRSxhQUFhO29CQUN2QixHQUFHO2lCQUNKLENBQUMsQ0FBQyxDQUFDO2dCQUNKLE9BQU8sQ0FBQyxHQUFHLENBQUMsYUFBYSxHQUFHLENBQUMsU0FBUyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsS0FBSyxDQUFDLENBQUM7WUFDdEQsQ0FBQztZQUFDLE9BQU8sS0FBVSxFQUFFLENBQUM7Z0JBQ3BCLGlDQUFpQztnQkFDakMsSUFBSSxLQUFLLENBQUMsT0FBTyxFQUFFLFFBQVEsQ0FBQyxnQkFBZ0IsQ0FBQyxFQUFFLENBQUM7b0JBQzlDLE9BQU8sQ0FBQyxHQUFHLENBQUMsNkJBQTZCLEdBQUcsQ0FBQyxTQUFTLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxLQUFLLENBQUMsQ0FBQztnQkFDdEUsQ0FBQztxQkFBTSxDQUFDO29CQUNOLE1BQU0sS0FBSyxDQUFDO2dCQUNkLENBQUM7WUFDSCxDQUFDO1FBQ0gsQ0FBQztRQUVELE9BQU8sQ0FBQyxHQUFHLENBQUMsZ0NBQWdDLENBQUMsQ0FBQztRQUU5QyxPQUFPO1lBQ0wsVUFBVSxFQUFFLEdBQUc7WUFDZixJQUFJLEVBQUUsSUFBSSxDQUFDLFNBQVMsQ0FBQztnQkFDbkIsT0FBTyxFQUFFLDJDQUEyQzthQUNyRCxDQUFDO1NBQ0gsQ0FBQztJQUVKLENBQUM7SUFBQyxPQUFPLEtBQVUsRUFBRSxDQUFDO1FBQ3BCLE9BQU8sQ0FBQyxLQUFLLENBQUMsK0JBQStCLEVBQUUsS0FBSyxDQUFDLENBQUM7UUFDdEQsTUFBTSxLQUFLLENBQUM7SUFDZCxDQUFDO0FBQ0gsQ0FBQyxDQUFDO0FBbERXLFFBQUEsT0FBTyxXQWtEbEIiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEF1cm9yYSBBbmFseXRpY3MgU2NoZW1hIEluaXRpYWxpemF0aW9uXG4gKlxuICogQ3JlYXRlcyB0aGUgYW5hbHl0aWNzIHNjaGVtYSB3aXRoIHBhcnRpdGlvbmVkIHRhYmxlcyBmb3IgdGVsZW1ldHJ5LCBsb2NhdGlvbnMsIGFuZCBqb3VybmV5cy5cbiAqL1xuXG5pbXBvcnQgeyBSRFNEYXRhQ2xpZW50LCBFeGVjdXRlU3RhdGVtZW50Q29tbWFuZCwgQmF0Y2hFeGVjdXRlU3RhdGVtZW50Q29tbWFuZCB9IGZyb20gJ0Bhd3Mtc2RrL2NsaWVudC1yZHMtZGF0YSc7XG5cbmNvbnN0IHJkcyA9IG5ldyBSRFNEYXRhQ2xpZW50KHt9KTtcblxuY29uc3QgQ0xVU1RFUl9BUk4gPSBwcm9jZXNzLmVudi5DTFVTVEVSX0FSTiE7XG5jb25zdCBTRUNSRVRfQVJOID0gcHJvY2Vzcy5lbnYuU0VDUkVUX0FSTiE7XG5jb25zdCBEQVRBQkFTRV9OQU1FID0gcHJvY2Vzcy5lbnYuREFUQUJBU0VfTkFNRSE7XG5cbmNvbnN0IFNDSEVNQV9TUUwgPSBgXG4tLSBDcmVhdGUgYW5hbHl0aWNzIHNjaGVtYVxuQ1JFQVRFIFNDSEVNQSBJRiBOT1QgRVhJU1RTIGFuYWx5dGljcztcblxuLS0gRGV2aWNlcyB0YWJsZSAobm8gcGFydGl0aW9uaW5nIG5lZWRlZClcbkNSRUFURSBUQUJMRSBJRiBOT1QgRVhJU1RTIGFuYWx5dGljcy5kZXZpY2VzIChcbiAgc2VyaWFsX251bWJlciBWQVJDSEFSKDEwMCkgUFJJTUFSWSBLRVksXG4gIGRldmljZV91aWQgVkFSQ0hBUigxMDApLFxuICBuYW1lIFZBUkNIQVIoMjU1KSxcbiAgZmxlZXRfbmFtZSBWQVJDSEFSKDI1NSksXG4gIGZsZWV0X3VpZCBWQVJDSEFSKDEwMCksXG4gIHByb2R1Y3RfdWlkIFZBUkNIQVIoMTAwKSxcbiAgbGFzdF9zZWVuIEJJR0lOVCxcbiAgbGFzdF9sb2NhdGlvbl9sYXQgRE9VQkxFIFBSRUNJU0lPTixcbiAgbGFzdF9sb2NhdGlvbl9sb24gRE9VQkxFIFBSRUNJU0lPTixcbiAgc3RhdHVzIFZBUkNIQVIoNTApLFxuICB2b2x0YWdlIERPVUJMRSBQUkVDSVNJT04sXG4gIHRlbXBlcmF0dXJlIERPVUJMRSBQUkVDSVNJT04sXG4gIGNyZWF0ZWRfYXQgQklHSU5ULFxuICB1cGRhdGVkX2F0IEJJR0lOVFxuKTtcblxuQ1JFQVRFIElOREVYIElGIE5PVCBFWElTVFMgaWR4X2RldmljZXNfZmxlZXQgT04gYW5hbHl0aWNzLmRldmljZXMoZmxlZXRfdWlkKTtcbkNSRUFURSBJTkRFWCBJRiBOT1QgRVhJU1RTIGlkeF9kZXZpY2VzX3N0YXR1cyBPTiBhbmFseXRpY3MuZGV2aWNlcyhzdGF0dXMpO1xuQ1JFQVRFIElOREVYIElGIE5PVCBFWElTVFMgaWR4X2RldmljZXNfbGFzdF9zZWVuIE9OIGFuYWx5dGljcy5kZXZpY2VzKGxhc3Rfc2VlbiBERVNDKTtcblxuLS0gVGVsZW1ldHJ5IHRhYmxlIChwYXJ0aXRpb25lZCBieSB0aW1lKVxuQ1JFQVRFIFRBQkxFIElGIE5PVCBFWElTVFMgYW5hbHl0aWNzLnRlbGVtZXRyeSAoXG4gIGRldmljZV91aWQgVkFSQ0hBUigxMDApLFxuICBzZXJpYWxfbnVtYmVyIFZBUkNIQVIoMTAwKSxcbiAgdGltZSBUSU1FU1RBTVAgV0lUSCBUSU1FIFpPTkUsXG4gIHRlbXBlcmF0dXJlIERPVUJMRSBQUkVDSVNJT04sXG4gIGh1bWlkaXR5IERPVUJMRSBQUkVDSVNJT04sXG4gIHByZXNzdXJlIERPVUJMRSBQUkVDSVNJT04sXG4gIHZvbHRhZ2UgRE9VQkxFIFBSRUNJU0lPTixcbiAgZXZlbnRfdHlwZSBWQVJDSEFSKDEwMCksXG4gIFBSSU1BUlkgS0VZIChzZXJpYWxfbnVtYmVyLCB0aW1lKVxuKSBQQVJUSVRJT04gQlkgUkFOR0UgKHRpbWUpO1xuXG4tLSBDcmVhdGUgcGFydGl0aW9ucyBmb3IgdGVsZW1ldHJ5IChsYXN0IDYgbW9udGhzICsgbmV4dCA2IG1vbnRocylcbkNSRUFURSBUQUJMRSBJRiBOT1QgRVhJU1RTIGFuYWx5dGljcy50ZWxlbWV0cnlfMjAyNF9xNFxuICBQQVJUSVRJT04gT0YgYW5hbHl0aWNzLnRlbGVtZXRyeVxuICBGT1IgVkFMVUVTIEZST00gKCcyMDI0LTEwLTAxJykgVE8gKCcyMDI1LTAxLTAxJyk7XG5cbkNSRUFURSBUQUJMRSBJRiBOT1QgRVhJU1RTIGFuYWx5dGljcy50ZWxlbWV0cnlfMjAyNV9xMVxuICBQQVJUSVRJT04gT0YgYW5hbHl0aWNzLnRlbGVtZXRyeVxuICBGT1IgVkFMVUVTIEZST00gKCcyMDI1LTAxLTAxJykgVE8gKCcyMDI1LTA0LTAxJyk7XG5cbkNSRUFURSBUQUJMRSBJRiBOT1QgRVhJU1RTIGFuYWx5dGljcy50ZWxlbWV0cnlfMjAyNV9xMlxuICBQQVJUSVRJT04gT0YgYW5hbHl0aWNzLnRlbGVtZXRyeVxuICBGT1IgVkFMVUVTIEZST00gKCcyMDI1LTA0LTAxJykgVE8gKCcyMDI1LTA3LTAxJyk7XG5cbkNSRUFURSBUQUJMRSBJRiBOT1QgRVhJU1RTIGFuYWx5dGljcy50ZWxlbWV0cnlfMjAyNV9xM1xuICBQQVJUSVRJT04gT0YgYW5hbHl0aWNzLnRlbGVtZXRyeVxuICBGT1IgVkFMVUVTIEZST00gKCcyMDI1LTA3LTAxJykgVE8gKCcyMDI1LTEwLTAxJyk7XG5cbkNSRUFURSBUQUJMRSBJRiBOT1QgRVhJU1RTIGFuYWx5dGljcy50ZWxlbWV0cnlfMjAyNV9xNFxuICBQQVJUSVRJT04gT0YgYW5hbHl0aWNzLnRlbGVtZXRyeVxuICBGT1IgVkFMVUVTIEZST00gKCcyMDI1LTEwLTAxJykgVE8gKCcyMDI2LTAxLTAxJyk7XG5cbkNSRUFURSBUQUJMRSBJRiBOT1QgRVhJU1RTIGFuYWx5dGljcy50ZWxlbWV0cnlfMjAyNl9xMVxuICBQQVJUSVRJT04gT0YgYW5hbHl0aWNzLnRlbGVtZXRyeVxuICBGT1IgVkFMVUVTIEZST00gKCcyMDI2LTAxLTAxJykgVE8gKCcyMDI2LTA0LTAxJyk7XG5cbkNSRUFURSBUQUJMRSBJRiBOT1QgRVhJU1RTIGFuYWx5dGljcy50ZWxlbWV0cnlfMjAyNl9xMlxuICBQQVJUSVRJT04gT0YgYW5hbHl0aWNzLnRlbGVtZXRyeVxuICBGT1IgVkFMVUVTIEZST00gKCcyMDI2LTA0LTAxJykgVE8gKCcyMDI2LTA3LTAxJyk7XG5cbkNSRUFURSBJTkRFWCBJRiBOT1QgRVhJU1RTIGlkeF90ZWxlbWV0cnlfZGV2aWNlX3RpbWUgT04gYW5hbHl0aWNzLnRlbGVtZXRyeShzZXJpYWxfbnVtYmVyLCB0aW1lIERFU0MpO1xuQ1JFQVRFIElOREVYIElGIE5PVCBFWElTVFMgaWR4X3RlbGVtZXRyeV9ldmVudF90eXBlIE9OIGFuYWx5dGljcy50ZWxlbWV0cnkoZXZlbnRfdHlwZSwgdGltZSBERVNDKTtcblxuLS0gTG9jYXRpb25zIHRhYmxlIChwYXJ0aXRpb25lZCBieSB0aW1lKVxuQ1JFQVRFIFRBQkxFIElGIE5PVCBFWElTVFMgYW5hbHl0aWNzLmxvY2F0aW9ucyAoXG4gIGRldmljZV91aWQgVkFSQ0hBUigxMDApLFxuICBzZXJpYWxfbnVtYmVyIFZBUkNIQVIoMTAwKSxcbiAgdGltZSBUSU1FU1RBTVAgV0lUSCBUSU1FIFpPTkUsXG4gIGxhdCBET1VCTEUgUFJFQ0lTSU9OLFxuICBsb24gRE9VQkxFIFBSRUNJU0lPTixcbiAgc291cmNlIFZBUkNIQVIoNTApLFxuICBqb3VybmV5X2lkIEJJR0lOVCxcbiAgUFJJTUFSWSBLRVkgKHNlcmlhbF9udW1iZXIsIHRpbWUpXG4pIFBBUlRJVElPTiBCWSBSQU5HRSAodGltZSk7XG5cbi0tIENyZWF0ZSBwYXJ0aXRpb25zIGZvciBsb2NhdGlvbnNcbkNSRUFURSBUQUJMRSBJRiBOT1QgRVhJU1RTIGFuYWx5dGljcy5sb2NhdGlvbnNfMjAyNF9xNFxuICBQQVJUSVRJT04gT0YgYW5hbHl0aWNzLmxvY2F0aW9uc1xuICBGT1IgVkFMVUVTIEZST00gKCcyMDI0LTEwLTAxJykgVE8gKCcyMDI1LTAxLTAxJyk7XG5cbkNSRUFURSBUQUJMRSBJRiBOT1QgRVhJU1RTIGFuYWx5dGljcy5sb2NhdGlvbnNfMjAyNV9xMVxuICBQQVJUSVRJT04gT0YgYW5hbHl0aWNzLmxvY2F0aW9uc1xuICBGT1IgVkFMVUVTIEZST00gKCcyMDI1LTAxLTAxJykgVE8gKCcyMDI1LTA0LTAxJyk7XG5cbkNSRUFURSBUQUJMRSBJRiBOT1QgRVhJU1RTIGFuYWx5dGljcy5sb2NhdGlvbnNfMjAyNV9xMlxuICBQQVJUSVRJT04gT0YgYW5hbHl0aWNzLmxvY2F0aW9uc1xuICBGT1IgVkFMVUVTIEZST00gKCcyMDI1LTA0LTAxJykgVE8gKCcyMDI1LTA3LTAxJyk7XG5cbkNSRUFURSBUQUJMRSBJRiBOT1QgRVhJU1RTIGFuYWx5dGljcy5sb2NhdGlvbnNfMjAyNV9xM1xuICBQQVJUSVRJT04gT0YgYW5hbHl0aWNzLmxvY2F0aW9uc1xuICBGT1IgVkFMVUVTIEZST00gKCcyMDI1LTA3LTAxJykgVE8gKCcyMDI1LTEwLTAxJyk7XG5cbkNSRUFURSBUQUJMRSBJRiBOT1QgRVhJU1RTIGFuYWx5dGljcy5sb2NhdGlvbnNfMjAyNV9xNFxuICBQQVJUSVRJT04gT0YgYW5hbHl0aWNzLmxvY2F0aW9uc1xuICBGT1IgVkFMVUVTIEZST00gKCcyMDI1LTEwLTAxJykgVE8gKCcyMDI2LTAxLTAxJyk7XG5cbkNSRUFURSBUQUJMRSBJRiBOT1QgRVhJU1RTIGFuYWx5dGljcy5sb2NhdGlvbnNfMjAyNl9xMVxuICBQQVJUSVRJT04gT0YgYW5hbHl0aWNzLmxvY2F0aW9uc1xuICBGT1IgVkFMVUVTIEZST00gKCcyMDI2LTAxLTAxJykgVE8gKCcyMDI2LTA0LTAxJyk7XG5cbkNSRUFURSBUQUJMRSBJRiBOT1QgRVhJU1RTIGFuYWx5dGljcy5sb2NhdGlvbnNfMjAyNl9xMlxuICBQQVJUSVRJT04gT0YgYW5hbHl0aWNzLmxvY2F0aW9uc1xuICBGT1IgVkFMVUVTIEZST00gKCcyMDI2LTA0LTAxJykgVE8gKCcyMDI2LTA3LTAxJyk7XG5cbkNSRUFURSBJTkRFWCBJRiBOT1QgRVhJU1RTIGlkeF9sb2NhdGlvbnNfZGV2aWNlX3RpbWUgT04gYW5hbHl0aWNzLmxvY2F0aW9ucyhzZXJpYWxfbnVtYmVyLCB0aW1lIERFU0MpO1xuQ1JFQVRFIElOREVYIElGIE5PVCBFWElTVFMgaWR4X2xvY2F0aW9uc19qb3VybmV5IE9OIGFuYWx5dGljcy5sb2NhdGlvbnMoc2VyaWFsX251bWJlciwgam91cm5leV9pZCk7XG5cbi0tIEFsZXJ0cyB0YWJsZSAobm8gcGFydGl0aW9uaW5nIGZvciBub3cgLSBsZXNzIGRhdGEpXG5DUkVBVEUgVEFCTEUgSUYgTk9UIEVYSVNUUyBhbmFseXRpY3MuYWxlcnRzIChcbiAgYWxlcnRfaWQgVkFSQ0hBUigxMDApIFBSSU1BUlkgS0VZLFxuICBkZXZpY2VfdWlkIFZBUkNIQVIoMTAwKSxcbiAgc2VyaWFsX251bWJlciBWQVJDSEFSKDEwMCksXG4gIGFsZXJ0X3R5cGUgVkFSQ0hBUigxMDApLFxuICBzZXZlcml0eSBWQVJDSEFSKDUwKSxcbiAgbWVzc2FnZSBURVhULFxuICBhY2tub3dsZWRnZWQgQk9PTEVBTixcbiAgY3JlYXRlZF9hdCBCSUdJTlQsXG4gIGFja25vd2xlZGdlZF9hdCBCSUdJTlQsXG4gIGFja25vd2xlZGdlZF9ieSBWQVJDSEFSKDI1NSlcbik7XG5cbkNSRUFURSBJTkRFWCBJRiBOT1QgRVhJU1RTIGlkeF9hbGVydHNfZGV2aWNlIE9OIGFuYWx5dGljcy5hbGVydHMoc2VyaWFsX251bWJlciwgY3JlYXRlZF9hdCBERVNDKTtcbkNSRUFURSBJTkRFWCBJRiBOT1QgRVhJU1RTIGlkeF9hbGVydHNfc3RhdHVzIE9OIGFuYWx5dGljcy5hbGVydHMoYWNrbm93bGVkZ2VkLCBjcmVhdGVkX2F0IERFU0MpO1xuXG4tLSBKb3VybmV5cyB0YWJsZSAobm8gcGFydGl0aW9uaW5nIGZvciBub3cpXG5DUkVBVEUgVEFCTEUgSUYgTk9UIEVYSVNUUyBhbmFseXRpY3Muam91cm5leXMgKFxuICBkZXZpY2VfdWlkIFZBUkNIQVIoMTAwKSxcbiAgc2VyaWFsX251bWJlciBWQVJDSEFSKDEwMCksXG4gIGpvdXJuZXlfaWQgQklHSU5ULFxuICBzdGFydF90aW1lIEJJR0lOVCxcbiAgZW5kX3RpbWUgQklHSU5ULFxuICBzdGF0dXMgVkFSQ0hBUig1MCksXG4gIGRpc3RhbmNlX2ttIERPVUJMRSBQUkVDSVNJT04sXG4gIFBSSU1BUlkgS0VZIChzZXJpYWxfbnVtYmVyLCBqb3VybmV5X2lkKVxuKTtcblxuQ1JFQVRFIElOREVYIElGIE5PVCBFWElTVFMgaWR4X2pvdXJuZXlzX3N0YXR1cyBPTiBhbmFseXRpY3Muam91cm5leXMoc3RhdHVzLCBzdGFydF90aW1lIERFU0MpO1xuQ1JFQVRFIElOREVYIElGIE5PVCBFWElTVFMgaWR4X2pvdXJuZXlzX2RldmljZV90aW1lIE9OIGFuYWx5dGljcy5qb3VybmV5cyhzZXJpYWxfbnVtYmVyLCBzdGFydF90aW1lIERFU0MpO1xuXG4tLSBNYXRlcmlhbGl6ZWQgdmlldyBmb3IgZGV2aWNlIHN0YXRzIChmb3IgZmFzdGVyIHF1ZXJpZXMpXG5DUkVBVEUgTUFURVJJQUxJWkVEIFZJRVcgSUYgTk9UIEVYSVNUUyBhbmFseXRpY3MuZGV2aWNlX3N0YXRzIEFTXG5TRUxFQ1RcbiAgZC5zZXJpYWxfbnVtYmVyLFxuICBkLm5hbWUsXG4gIGQuZmxlZXRfbmFtZSxcbiAgZC5zdGF0dXMsXG4gIGQubGFzdF9zZWVuLFxuICBDT1VOVChESVNUSU5DVCB0LnRpbWUpIGFzIHRlbGVtZXRyeV9jb3VudCxcbiAgQ09VTlQoRElTVElOQ1QgYS5hbGVydF9pZCkgYXMgYWxlcnRfY291bnQsXG4gIE1BWCh0LnRlbXBlcmF0dXJlKSBhcyBtYXhfdGVtcCxcbiAgTUlOKHQudGVtcGVyYXR1cmUpIGFzIG1pbl90ZW1wLFxuICBBVkcodC50ZW1wZXJhdHVyZSkgYXMgYXZnX3RlbXBcbkZST00gYW5hbHl0aWNzLmRldmljZXMgZFxuTEVGVCBKT0lOIGFuYWx5dGljcy50ZWxlbWV0cnkgdCBPTiBkLnNlcmlhbF9udW1iZXIgPSB0LnNlcmlhbF9udW1iZXJcbiAgQU5EIHQudGltZSA+IE5PVygpIC0gSU5URVJWQUwgJzMwIGRheXMnXG5MRUZUIEpPSU4gYW5hbHl0aWNzLmFsZXJ0cyBhIE9OIGQuc2VyaWFsX251bWJlciA9IGEuc2VyaWFsX251bWJlclxuICBBTkQgYS5jcmVhdGVkX2F0ID4gRVhUUkFDVChFUE9DSCBGUk9NIE5PVygpIC0gSU5URVJWQUwgJzMwIGRheXMnKVxuR1JPVVAgQlkgZC5zZXJpYWxfbnVtYmVyLCBkLm5hbWUsIGQuZmxlZXRfbmFtZSwgZC5zdGF0dXMsIGQubGFzdF9zZWVuO1xuXG4tLSBHcmFudCBwZXJtaXNzaW9uc1xuR1JBTlQgVVNBR0UgT04gU0NIRU1BIGFuYWx5dGljcyBUTyBQVUJMSUM7XG5HUkFOVCBTRUxFQ1QgT04gQUxMIFRBQkxFUyBJTiBTQ0hFTUEgYW5hbHl0aWNzIFRPIFBVQkxJQztcbmA7XG5cbmV4cG9ydCBjb25zdCBoYW5kbGVyID0gYXN5bmMgKCk6IFByb21pc2U8YW55PiA9PiB7XG4gIHRyeSB7XG4gICAgY29uc29sZS5sb2coJ0luaXRpYWxpemluZyBBdXJvcmEgYW5hbHl0aWNzIHNjaGVtYS4uLicpO1xuXG4gICAgLy8gU3BsaXQgU1FMIGludG8gaW5kaXZpZHVhbCBzdGF0ZW1lbnRzIGFuZCByZW1vdmUgY29tbWVudC1vbmx5IGxpbmVzXG4gICAgY29uc3Qgc3RhdGVtZW50cyA9IFNDSEVNQV9TUUxcbiAgICAgIC5zcGxpdCgnOycpXG4gICAgICAubWFwKHMgPT4gcy50cmltKCkpXG4gICAgICAuZmlsdGVyKHMgPT4gcy5sZW5ndGggPiAwKVxuICAgICAgLm1hcChzID0+IHtcbiAgICAgICAgLy8gUmVtb3ZlIGNvbW1lbnQgbGluZXMgZnJvbSB0aGUgc3RhcnQgb2YgZWFjaCBzdGF0ZW1lbnRcbiAgICAgICAgY29uc3QgbGluZXMgPSBzLnNwbGl0KCdcXG4nKTtcbiAgICAgICAgY29uc3Qgbm9uQ29tbWVudExpbmVzID0gbGluZXMuZmlsdGVyKGxpbmUgPT4gIWxpbmUudHJpbSgpLnN0YXJ0c1dpdGgoJy0tJykpO1xuICAgICAgICByZXR1cm4gbm9uQ29tbWVudExpbmVzLmpvaW4oJ1xcbicpLnRyaW0oKTtcbiAgICAgIH0pXG4gICAgICAuZmlsdGVyKHMgPT4gcy5sZW5ndGggPiAwKTtcblxuICAgIC8vIEV4ZWN1dGUgZWFjaCBzdGF0ZW1lbnRcbiAgICBmb3IgKGNvbnN0IHNxbCBvZiBzdGF0ZW1lbnRzKSB7XG4gICAgICB0cnkge1xuICAgICAgICBhd2FpdCByZHMuc2VuZChuZXcgRXhlY3V0ZVN0YXRlbWVudENvbW1hbmQoe1xuICAgICAgICAgIHJlc291cmNlQXJuOiBDTFVTVEVSX0FSTixcbiAgICAgICAgICBzZWNyZXRBcm46IFNFQ1JFVF9BUk4sXG4gICAgICAgICAgZGF0YWJhc2U6IERBVEFCQVNFX05BTUUsXG4gICAgICAgICAgc3FsLFxuICAgICAgICB9KSk7XG4gICAgICAgIGNvbnNvbGUubG9nKGBFeGVjdXRlZDogJHtzcWwuc3Vic3RyaW5nKDAsIDUwKX0uLi5gKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICAgICAgLy8gSWdub3JlIFwiYWxyZWFkeSBleGlzdHNcIiBlcnJvcnNcbiAgICAgICAgaWYgKGVycm9yLm1lc3NhZ2U/LmluY2x1ZGVzKCdhbHJlYWR5IGV4aXN0cycpKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coYFNraXBwZWQgKGFscmVhZHkgZXhpc3RzKTogJHtzcWwuc3Vic3RyaW5nKDAsIDUwKX0uLi5gKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnNvbGUubG9nKCdTY2hlbWEgaW5pdGlhbGl6YXRpb24gY29tcGxldGUnKTtcblxuICAgIHJldHVybiB7XG4gICAgICBzdGF0dXNDb2RlOiAyMDAsXG4gICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgIG1lc3NhZ2U6ICdBbmFseXRpY3Mgc2NoZW1hIGluaXRpYWxpemVkIHN1Y2Nlc3NmdWxseScsXG4gICAgICB9KSxcbiAgICB9O1xuXG4gIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICBjb25zb2xlLmVycm9yKCdTY2hlbWEgaW5pdGlhbGl6YXRpb24gZmFpbGVkOicsIGVycm9yKTtcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxufTtcbiJdfQ==