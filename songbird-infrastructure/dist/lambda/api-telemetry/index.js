"use strict";
/**
 * Telemetry API Lambda
 *
 * Queries DynamoDB for device telemetry data:
 * - GET /devices/{device_uid}/telemetry - Get telemetry history
 * - GET /devices/{device_uid}/location - Get location history
 * - GET /devices/{device_uid}/power - Get Mojo power history
 * - GET /devices/{device_uid}/health - Get health event history
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.handler = void 0;
const client_dynamodb_1 = require("@aws-sdk/client-dynamodb");
const lib_dynamodb_1 = require("@aws-sdk/lib-dynamodb");
const ddbClient = new client_dynamodb_1.DynamoDBClient({});
const docClient = lib_dynamodb_1.DynamoDBDocumentClient.from(ddbClient);
const TELEMETRY_TABLE = process.env.TELEMETRY_TABLE;
const handler = async (event) => {
    console.log('Request:', JSON.stringify(event));
    const corsHeaders = {
        'Access-Control-Allow-Origin': '*',
        'Access-Control-Allow-Headers': 'Content-Type,Authorization',
        'Access-Control-Allow-Methods': 'GET,OPTIONS',
    };
    try {
        // HTTP API v2 uses requestContext.http.method, REST API v1 uses httpMethod
        const method = event.requestContext?.http?.method || event.httpMethod;
        const path = event.requestContext?.http?.path || event.path;
        if (method === 'OPTIONS') {
            return { statusCode: 200, headers: corsHeaders, body: '' };
        }
        const deviceUid = event.pathParameters?.device_uid;
        if (!deviceUid) {
            return {
                statusCode: 400,
                headers: corsHeaders,
                body: JSON.stringify({ error: 'device_uid required' }),
            };
        }
        const queryParams = event.queryStringParameters || {};
        // Parse time range
        const hours = parseInt(queryParams.hours || '24');
        const limit = parseInt(queryParams.limit || '1000');
        if (path.endsWith('/location')) {
            return await getLocationHistory(deviceUid, hours, limit, corsHeaders);
        }
        if (path.endsWith('/power')) {
            return await getPowerHistory(deviceUid, hours, limit, corsHeaders);
        }
        if (path.endsWith('/health')) {
            return await getHealthHistory(deviceUid, hours, limit, corsHeaders);
        }
        return await getTelemetryHistory(deviceUid, hours, limit, corsHeaders);
    }
    catch (error) {
        console.error('Error:', error);
        return {
            statusCode: 500,
            headers: corsHeaders,
            body: JSON.stringify({ error: 'Internal server error' }),
        };
    }
};
exports.handler = handler;
async function getTelemetryHistory(deviceUid, hours, limit, headers) {
    const cutoffTime = Date.now() - (hours * 60 * 60 * 1000);
    // Use the event-type-index GSI to efficiently query by data_type
    // The sort key is formatted as {data_type}#{timestamp}
    const cutoffKey = `telemetry#${cutoffTime}`;
    const endKey = `telemetry#${Date.now() + 1000}`; // Slightly in future to include latest
    // For higher limits, fetch all data in range then apply limit at the end
    // This ensures we get the complete time range, not just the N most recent
    const fetchAll = limit > 1000;
    let allItems = [];
    let lastEvaluatedKey;
    do {
        const command = new lib_dynamodb_1.QueryCommand({
            TableName: TELEMETRY_TABLE,
            IndexName: 'event-type-index',
            KeyConditionExpression: 'device_uid = :device_uid AND event_type_timestamp BETWEEN :start AND :end',
            ExpressionAttributeValues: {
                ':device_uid': deviceUid,
                ':start': cutoffKey,
                ':end': endKey,
            },
            ScanIndexForward: true, // Chronological order (oldest first)
            ...(fetchAll ? {} : { Limit: limit }),
            ...(lastEvaluatedKey ? { ExclusiveStartKey: lastEvaluatedKey } : {}),
        });
        const result = await docClient.send(command);
        allItems = allItems.concat(result.Items || []);
        lastEvaluatedKey = result.LastEvaluatedKey;
        // Stop if we have enough items or if fetchAll is false
        if (!fetchAll || allItems.length >= limit)
            break;
    } while (lastEvaluatedKey);
    // Apply limit and reverse to get newest-first order for frontend
    const items = allItems.slice(-limit).reverse();
    // Transform to API response format
    // Note: voltage is no longer included in track.qo telemetry; battery info comes from power API
    const telemetry = items.map((item) => ({
        time: new Date(item.timestamp).toISOString(),
        temperature: item.temperature,
        humidity: item.humidity,
        pressure: item.pressure,
        motion: item.motion,
    }));
    return {
        statusCode: 200,
        headers,
        body: JSON.stringify({
            device_uid: deviceUid,
            hours,
            count: telemetry.length,
            telemetry,
        }),
    };
}
async function getLocationHistory(deviceUid, hours, limit, headers) {
    const cutoffTime = Date.now() - (hours * 60 * 60 * 1000);
    // Use the event-type-index GSI to efficiently query telemetry records
    const cutoffKey = `telemetry#${cutoffTime}`;
    const endKey = `telemetry#${Date.now() + 1000}`;
    const command = new lib_dynamodb_1.QueryCommand({
        TableName: TELEMETRY_TABLE,
        IndexName: 'event-type-index',
        KeyConditionExpression: 'device_uid = :device_uid AND event_type_timestamp BETWEEN :start AND :end',
        FilterExpression: 'attribute_exists(latitude)',
        ExpressionAttributeValues: {
            ':device_uid': deviceUid,
            ':start': cutoffKey,
            ':end': endKey,
        },
        ScanIndexForward: false, // Newest first
        Limit: limit,
    });
    const result = await docClient.send(command);
    // Transform to API response format
    const locations = (result.Items || [])
        .filter((item) => item.latitude !== undefined && item.longitude !== undefined)
        .map((item) => ({
        time: new Date(item.timestamp).toISOString(),
        lat: item.latitude,
        lon: item.longitude,
        source: item.location_source,
    }));
    return {
        statusCode: 200,
        headers,
        body: JSON.stringify({
            device_uid: deviceUid,
            hours,
            count: locations.length,
            locations,
        }),
    };
}
async function getPowerHistory(deviceUid, hours, limit, headers) {
    const cutoffTime = Date.now() - (hours * 60 * 60 * 1000);
    // Use the event-type-index GSI to efficiently query power records
    const cutoffKey = `power#${cutoffTime}`;
    const endKey = `power#${Date.now() + 1000}`;
    const command = new lib_dynamodb_1.QueryCommand({
        TableName: TELEMETRY_TABLE,
        IndexName: 'event-type-index',
        KeyConditionExpression: 'device_uid = :device_uid AND event_type_timestamp BETWEEN :start AND :end',
        ExpressionAttributeValues: {
            ':device_uid': deviceUid,
            ':start': cutoffKey,
            ':end': endKey,
        },
        ScanIndexForward: false, // Newest first
        Limit: limit,
    });
    const result = await docClient.send(command);
    // Transform to API response format
    const power = (result.Items || []).map((item) => ({
        time: new Date(item.timestamp).toISOString(),
        voltage: item.mojo_voltage,
        milliamp_hours: item.milliamp_hours,
    }));
    return {
        statusCode: 200,
        headers,
        body: JSON.stringify({
            device_uid: deviceUid,
            hours,
            count: power.length,
            power,
        }),
    };
}
async function getHealthHistory(deviceUid, hours, limit, headers) {
    const cutoffTime = Date.now() - (hours * 60 * 60 * 1000);
    // Use the event-type-index GSI to efficiently query health records
    const cutoffKey = `health#${cutoffTime}`;
    const endKey = `health#${Date.now() + 1000}`;
    const command = new lib_dynamodb_1.QueryCommand({
        TableName: TELEMETRY_TABLE,
        IndexName: 'event-type-index',
        KeyConditionExpression: 'device_uid = :device_uid AND event_type_timestamp BETWEEN :start AND :end',
        ExpressionAttributeValues: {
            ':device_uid': deviceUid,
            ':start': cutoffKey,
            ':end': endKey,
        },
        ScanIndexForward: false, // Newest first
        Limit: limit,
    });
    const result = await docClient.send(command);
    // Transform to API response format
    const health = (result.Items || []).map((item) => ({
        time: new Date(item.timestamp).toISOString(),
        method: item.method,
        text: item.text,
        voltage: item.voltage,
        voltage_mode: item.voltage_mode,
        milliamp_hours: item.milliamp_hours,
    }));
    return {
        statusCode: 200,
        headers,
        body: JSON.stringify({
            device_uid: deviceUid,
            hours,
            count: health.length,
            health,
        }),
    };
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi9sYW1iZGEvYXBpLXRlbGVtZXRyeS9pbmRleC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUE7Ozs7Ozs7O0dBUUc7OztBQUVILDhEQUEwRDtBQUMxRCx3REFBNkU7QUFHN0UsTUFBTSxTQUFTLEdBQUcsSUFBSSxnQ0FBYyxDQUFDLEVBQUUsQ0FBQyxDQUFDO0FBQ3pDLE1BQU0sU0FBUyxHQUFHLHFDQUFzQixDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQztBQUV6RCxNQUFNLGVBQWUsR0FBRyxPQUFPLENBQUMsR0FBRyxDQUFDLGVBQWdCLENBQUM7QUFFOUMsTUFBTSxPQUFPLEdBQUcsS0FBSyxFQUFFLEtBQTJCLEVBQWtDLEVBQUU7SUFDM0YsT0FBTyxDQUFDLEdBQUcsQ0FBQyxVQUFVLEVBQUUsSUFBSSxDQUFDLFNBQVMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDO0lBRS9DLE1BQU0sV0FBVyxHQUFHO1FBQ2xCLDZCQUE2QixFQUFFLEdBQUc7UUFDbEMsOEJBQThCLEVBQUUsNEJBQTRCO1FBQzVELDhCQUE4QixFQUFFLGFBQWE7S0FDOUMsQ0FBQztJQUVGLElBQUksQ0FBQztRQUNILDJFQUEyRTtRQUMzRSxNQUFNLE1BQU0sR0FBSSxLQUFLLENBQUMsY0FBc0IsRUFBRSxJQUFJLEVBQUUsTUFBTSxJQUFJLEtBQUssQ0FBQyxVQUFVLENBQUM7UUFDL0UsTUFBTSxJQUFJLEdBQUksS0FBSyxDQUFDLGNBQXNCLEVBQUUsSUFBSSxFQUFFLElBQUksSUFBSSxLQUFLLENBQUMsSUFBSSxDQUFDO1FBRXJFLElBQUksTUFBTSxLQUFLLFNBQVMsRUFBRSxDQUFDO1lBQ3pCLE9BQU8sRUFBRSxVQUFVLEVBQUUsR0FBRyxFQUFFLE9BQU8sRUFBRSxXQUFXLEVBQUUsSUFBSSxFQUFFLEVBQUUsRUFBRSxDQUFDO1FBQzdELENBQUM7UUFFRCxNQUFNLFNBQVMsR0FBRyxLQUFLLENBQUMsY0FBYyxFQUFFLFVBQVUsQ0FBQztRQUNuRCxJQUFJLENBQUMsU0FBUyxFQUFFLENBQUM7WUFDZixPQUFPO2dCQUNMLFVBQVUsRUFBRSxHQUFHO2dCQUNmLE9BQU8sRUFBRSxXQUFXO2dCQUNwQixJQUFJLEVBQUUsSUFBSSxDQUFDLFNBQVMsQ0FBQyxFQUFFLEtBQUssRUFBRSxxQkFBcUIsRUFBRSxDQUFDO2FBQ3ZELENBQUM7UUFDSixDQUFDO1FBRUQsTUFBTSxXQUFXLEdBQUcsS0FBSyxDQUFDLHFCQUFxQixJQUFJLEVBQUUsQ0FBQztRQUV0RCxtQkFBbUI7UUFDbkIsTUFBTSxLQUFLLEdBQUcsUUFBUSxDQUFDLFdBQVcsQ0FBQyxLQUFLLElBQUksSUFBSSxDQUFDLENBQUM7UUFDbEQsTUFBTSxLQUFLLEdBQUcsUUFBUSxDQUFDLFdBQVcsQ0FBQyxLQUFLLElBQUksTUFBTSxDQUFDLENBQUM7UUFFcEQsSUFBSSxJQUFJLENBQUMsUUFBUSxDQUFDLFdBQVcsQ0FBQyxFQUFFLENBQUM7WUFDL0IsT0FBTyxNQUFNLGtCQUFrQixDQUFDLFNBQVMsRUFBRSxLQUFLLEVBQUUsS0FBSyxFQUFFLFdBQVcsQ0FBQyxDQUFDO1FBQ3hFLENBQUM7UUFFRCxJQUFJLElBQUksQ0FBQyxRQUFRLENBQUMsUUFBUSxDQUFDLEVBQUUsQ0FBQztZQUM1QixPQUFPLE1BQU0sZUFBZSxDQUFDLFNBQVMsRUFBRSxLQUFLLEVBQUUsS0FBSyxFQUFFLFdBQVcsQ0FBQyxDQUFDO1FBQ3JFLENBQUM7UUFFRCxJQUFJLElBQUksQ0FBQyxRQUFRLENBQUMsU0FBUyxDQUFDLEVBQUUsQ0FBQztZQUM3QixPQUFPLE1BQU0sZ0JBQWdCLENBQUMsU0FBUyxFQUFFLEtBQUssRUFBRSxLQUFLLEVBQUUsV0FBVyxDQUFDLENBQUM7UUFDdEUsQ0FBQztRQUVELE9BQU8sTUFBTSxtQkFBbUIsQ0FBQyxTQUFTLEVBQUUsS0FBSyxFQUFFLEtBQUssRUFBRSxXQUFXLENBQUMsQ0FBQztJQUN6RSxDQUFDO0lBQUMsT0FBTyxLQUFLLEVBQUUsQ0FBQztRQUNmLE9BQU8sQ0FBQyxLQUFLLENBQUMsUUFBUSxFQUFFLEtBQUssQ0FBQyxDQUFDO1FBQy9CLE9BQU87WUFDTCxVQUFVLEVBQUUsR0FBRztZQUNmLE9BQU8sRUFBRSxXQUFXO1lBQ3BCLElBQUksRUFBRSxJQUFJLENBQUMsU0FBUyxDQUFDLEVBQUUsS0FBSyxFQUFFLHVCQUF1QixFQUFFLENBQUM7U0FDekQsQ0FBQztJQUNKLENBQUM7QUFDSCxDQUFDLENBQUM7QUF0RFcsUUFBQSxPQUFPLFdBc0RsQjtBQUVGLEtBQUssVUFBVSxtQkFBbUIsQ0FDaEMsU0FBaUIsRUFDakIsS0FBYSxFQUNiLEtBQWEsRUFDYixPQUErQjtJQUUvQixNQUFNLFVBQVUsR0FBRyxJQUFJLENBQUMsR0FBRyxFQUFFLEdBQUcsQ0FBQyxLQUFLLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxJQUFJLENBQUMsQ0FBQztJQUV6RCxpRUFBaUU7SUFDakUsdURBQXVEO0lBQ3ZELE1BQU0sU0FBUyxHQUFHLGFBQWEsVUFBVSxFQUFFLENBQUM7SUFDNUMsTUFBTSxNQUFNLEdBQUcsYUFBYSxJQUFJLENBQUMsR0FBRyxFQUFFLEdBQUcsSUFBSSxFQUFFLENBQUMsQ0FBQyx1Q0FBdUM7SUFFeEYseUVBQXlFO0lBQ3pFLDBFQUEwRTtJQUMxRSxNQUFNLFFBQVEsR0FBRyxLQUFLLEdBQUcsSUFBSSxDQUFDO0lBRTlCLElBQUksUUFBUSxHQUEwQixFQUFFLENBQUM7SUFDekMsSUFBSSxnQkFBaUQsQ0FBQztJQUV0RCxHQUFHLENBQUM7UUFDRixNQUFNLE9BQU8sR0FBRyxJQUFJLDJCQUFZLENBQUM7WUFDL0IsU0FBUyxFQUFFLGVBQWU7WUFDMUIsU0FBUyxFQUFFLGtCQUFrQjtZQUM3QixzQkFBc0IsRUFBRSwyRUFBMkU7WUFDbkcseUJBQXlCLEVBQUU7Z0JBQ3pCLGFBQWEsRUFBRSxTQUFTO2dCQUN4QixRQUFRLEVBQUUsU0FBUztnQkFDbkIsTUFBTSxFQUFFLE1BQU07YUFDZjtZQUNELGdCQUFnQixFQUFFLElBQUksRUFBRSxxQ0FBcUM7WUFDN0QsR0FBRyxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxFQUFFLEtBQUssRUFBRSxLQUFLLEVBQUUsQ0FBQztZQUNyQyxHQUFHLENBQUMsZ0JBQWdCLENBQUMsQ0FBQyxDQUFDLEVBQUUsaUJBQWlCLEVBQUUsZ0JBQWdCLEVBQUUsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDO1NBQ3JFLENBQUMsQ0FBQztRQUVILE1BQU0sTUFBTSxHQUFHLE1BQU0sU0FBUyxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQztRQUM3QyxRQUFRLEdBQUcsUUFBUSxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsS0FBSyxJQUFJLEVBQUUsQ0FBQyxDQUFDO1FBQy9DLGdCQUFnQixHQUFHLE1BQU0sQ0FBQyxnQkFBZ0IsQ0FBQztRQUUzQyx1REFBdUQ7UUFDdkQsSUFBSSxDQUFDLFFBQVEsSUFBSSxRQUFRLENBQUMsTUFBTSxJQUFJLEtBQUs7WUFBRSxNQUFNO0lBQ25ELENBQUMsUUFBUSxnQkFBZ0IsRUFBRTtJQUUzQixpRUFBaUU7SUFDakUsTUFBTSxLQUFLLEdBQUcsUUFBUSxDQUFDLEtBQUssQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLE9BQU8sRUFBRSxDQUFDO0lBRS9DLG1DQUFtQztJQUNuQywrRkFBK0Y7SUFDL0YsTUFBTSxTQUFTLEdBQUcsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDLElBQUksRUFBRSxFQUFFLENBQUMsQ0FBQztRQUNyQyxJQUFJLEVBQUUsSUFBSSxJQUFJLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDLFdBQVcsRUFBRTtRQUM1QyxXQUFXLEVBQUUsSUFBSSxDQUFDLFdBQVc7UUFDN0IsUUFBUSxFQUFFLElBQUksQ0FBQyxRQUFRO1FBQ3ZCLFFBQVEsRUFBRSxJQUFJLENBQUMsUUFBUTtRQUN2QixNQUFNLEVBQUUsSUFBSSxDQUFDLE1BQU07S0FDcEIsQ0FBQyxDQUFDLENBQUM7SUFFSixPQUFPO1FBQ0wsVUFBVSxFQUFFLEdBQUc7UUFDZixPQUFPO1FBQ1AsSUFBSSxFQUFFLElBQUksQ0FBQyxTQUFTLENBQUM7WUFDbkIsVUFBVSxFQUFFLFNBQVM7WUFDckIsS0FBSztZQUNMLEtBQUssRUFBRSxTQUFTLENBQUMsTUFBTTtZQUN2QixTQUFTO1NBQ1YsQ0FBQztLQUNILENBQUM7QUFDSixDQUFDO0FBRUQsS0FBSyxVQUFVLGtCQUFrQixDQUMvQixTQUFpQixFQUNqQixLQUFhLEVBQ2IsS0FBYSxFQUNiLE9BQStCO0lBRS9CLE1BQU0sVUFBVSxHQUFHLElBQUksQ0FBQyxHQUFHLEVBQUUsR0FBRyxDQUFDLEtBQUssR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLElBQUksQ0FBQyxDQUFDO0lBRXpELHNFQUFzRTtJQUN0RSxNQUFNLFNBQVMsR0FBRyxhQUFhLFVBQVUsRUFBRSxDQUFDO0lBQzVDLE1BQU0sTUFBTSxHQUFHLGFBQWEsSUFBSSxDQUFDLEdBQUcsRUFBRSxHQUFHLElBQUksRUFBRSxDQUFDO0lBRWhELE1BQU0sT0FBTyxHQUFHLElBQUksMkJBQVksQ0FBQztRQUMvQixTQUFTLEVBQUUsZUFBZTtRQUMxQixTQUFTLEVBQUUsa0JBQWtCO1FBQzdCLHNCQUFzQixFQUFFLDJFQUEyRTtRQUNuRyxnQkFBZ0IsRUFBRSw0QkFBNEI7UUFDOUMseUJBQXlCLEVBQUU7WUFDekIsYUFBYSxFQUFFLFNBQVM7WUFDeEIsUUFBUSxFQUFFLFNBQVM7WUFDbkIsTUFBTSxFQUFFLE1BQU07U0FDZjtRQUNELGdCQUFnQixFQUFFLEtBQUssRUFBRSxlQUFlO1FBQ3hDLEtBQUssRUFBRSxLQUFLO0tBQ2IsQ0FBQyxDQUFDO0lBRUgsTUFBTSxNQUFNLEdBQUcsTUFBTSxTQUFTLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDO0lBRTdDLG1DQUFtQztJQUNuQyxNQUFNLFNBQVMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxLQUFLLElBQUksRUFBRSxDQUFDO1NBQ25DLE1BQU0sQ0FBQyxDQUFDLElBQUksRUFBRSxFQUFFLENBQUMsSUFBSSxDQUFDLFFBQVEsS0FBSyxTQUFTLElBQUksSUFBSSxDQUFDLFNBQVMsS0FBSyxTQUFTLENBQUM7U0FDN0UsR0FBRyxDQUFDLENBQUMsSUFBSSxFQUFFLEVBQUUsQ0FBQyxDQUFDO1FBQ2QsSUFBSSxFQUFFLElBQUksSUFBSSxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQyxXQUFXLEVBQUU7UUFDNUMsR0FBRyxFQUFFLElBQUksQ0FBQyxRQUFRO1FBQ2xCLEdBQUcsRUFBRSxJQUFJLENBQUMsU0FBUztRQUNuQixNQUFNLEVBQUUsSUFBSSxDQUFDLGVBQWU7S0FDN0IsQ0FBQyxDQUFDLENBQUM7SUFFTixPQUFPO1FBQ0wsVUFBVSxFQUFFLEdBQUc7UUFDZixPQUFPO1FBQ1AsSUFBSSxFQUFFLElBQUksQ0FBQyxTQUFTLENBQUM7WUFDbkIsVUFBVSxFQUFFLFNBQVM7WUFDckIsS0FBSztZQUNMLEtBQUssRUFBRSxTQUFTLENBQUMsTUFBTTtZQUN2QixTQUFTO1NBQ1YsQ0FBQztLQUNILENBQUM7QUFDSixDQUFDO0FBRUQsS0FBSyxVQUFVLGVBQWUsQ0FDNUIsU0FBaUIsRUFDakIsS0FBYSxFQUNiLEtBQWEsRUFDYixPQUErQjtJQUUvQixNQUFNLFVBQVUsR0FBRyxJQUFJLENBQUMsR0FBRyxFQUFFLEdBQUcsQ0FBQyxLQUFLLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxJQUFJLENBQUMsQ0FBQztJQUV6RCxrRUFBa0U7SUFDbEUsTUFBTSxTQUFTLEdBQUcsU0FBUyxVQUFVLEVBQUUsQ0FBQztJQUN4QyxNQUFNLE1BQU0sR0FBRyxTQUFTLElBQUksQ0FBQyxHQUFHLEVBQUUsR0FBRyxJQUFJLEVBQUUsQ0FBQztJQUU1QyxNQUFNLE9BQU8sR0FBRyxJQUFJLDJCQUFZLENBQUM7UUFDL0IsU0FBUyxFQUFFLGVBQWU7UUFDMUIsU0FBUyxFQUFFLGtCQUFrQjtRQUM3QixzQkFBc0IsRUFBRSwyRUFBMkU7UUFDbkcseUJBQXlCLEVBQUU7WUFDekIsYUFBYSxFQUFFLFNBQVM7WUFDeEIsUUFBUSxFQUFFLFNBQVM7WUFDbkIsTUFBTSxFQUFFLE1BQU07U0FDZjtRQUNELGdCQUFnQixFQUFFLEtBQUssRUFBRSxlQUFlO1FBQ3hDLEtBQUssRUFBRSxLQUFLO0tBQ2IsQ0FBQyxDQUFDO0lBRUgsTUFBTSxNQUFNLEdBQUcsTUFBTSxTQUFTLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDO0lBRTdDLG1DQUFtQztJQUNuQyxNQUFNLEtBQUssR0FBRyxDQUFDLE1BQU0sQ0FBQyxLQUFLLElBQUksRUFBRSxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsSUFBSSxFQUFFLEVBQUUsQ0FBQyxDQUFDO1FBQ2hELElBQUksRUFBRSxJQUFJLElBQUksQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUMsV0FBVyxFQUFFO1FBQzVDLE9BQU8sRUFBRSxJQUFJLENBQUMsWUFBWTtRQUMxQixjQUFjLEVBQUUsSUFBSSxDQUFDLGNBQWM7S0FDcEMsQ0FBQyxDQUFDLENBQUM7SUFFSixPQUFPO1FBQ0wsVUFBVSxFQUFFLEdBQUc7UUFDZixPQUFPO1FBQ1AsSUFBSSxFQUFFLElBQUksQ0FBQyxTQUFTLENBQUM7WUFDbkIsVUFBVSxFQUFFLFNBQVM7WUFDckIsS0FBSztZQUNMLEtBQUssRUFBRSxLQUFLLENBQUMsTUFBTTtZQUNuQixLQUFLO1NBQ04sQ0FBQztLQUNILENBQUM7QUFDSixDQUFDO0FBRUQsS0FBSyxVQUFVLGdCQUFnQixDQUM3QixTQUFpQixFQUNqQixLQUFhLEVBQ2IsS0FBYSxFQUNiLE9BQStCO0lBRS9CLE1BQU0sVUFBVSxHQUFHLElBQUksQ0FBQyxHQUFHLEVBQUUsR0FBRyxDQUFDLEtBQUssR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLElBQUksQ0FBQyxDQUFDO0lBRXpELG1FQUFtRTtJQUNuRSxNQUFNLFNBQVMsR0FBRyxVQUFVLFVBQVUsRUFBRSxDQUFDO0lBQ3pDLE1BQU0sTUFBTSxHQUFHLFVBQVUsSUFBSSxDQUFDLEdBQUcsRUFBRSxHQUFHLElBQUksRUFBRSxDQUFDO0lBRTdDLE1BQU0sT0FBTyxHQUFHLElBQUksMkJBQVksQ0FBQztRQUMvQixTQUFTLEVBQUUsZUFBZTtRQUMxQixTQUFTLEVBQUUsa0JBQWtCO1FBQzdCLHNCQUFzQixFQUFFLDJFQUEyRTtRQUNuRyx5QkFBeUIsRUFBRTtZQUN6QixhQUFhLEVBQUUsU0FBUztZQUN4QixRQUFRLEVBQUUsU0FBUztZQUNuQixNQUFNLEVBQUUsTUFBTTtTQUNmO1FBQ0QsZ0JBQWdCLEVBQUUsS0FBSyxFQUFFLGVBQWU7UUFDeEMsS0FBSyxFQUFFLEtBQUs7S0FDYixDQUFDLENBQUM7SUFFSCxNQUFNLE1BQU0sR0FBRyxNQUFNLFNBQVMsQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUM7SUFFN0MsbUNBQW1DO0lBQ25DLE1BQU0sTUFBTSxHQUFHLENBQUMsTUFBTSxDQUFDLEtBQUssSUFBSSxFQUFFLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxJQUFJLEVBQUUsRUFBRSxDQUFDLENBQUM7UUFDakQsSUFBSSxFQUFFLElBQUksSUFBSSxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQyxXQUFXLEVBQUU7UUFDNUMsTUFBTSxFQUFFLElBQUksQ0FBQyxNQUFNO1FBQ25CLElBQUksRUFBRSxJQUFJLENBQUMsSUFBSTtRQUNmLE9BQU8sRUFBRSxJQUFJLENBQUMsT0FBTztRQUNyQixZQUFZLEVBQUUsSUFBSSxDQUFDLFlBQVk7UUFDL0IsY0FBYyxFQUFFLElBQUksQ0FBQyxjQUFjO0tBQ3BDLENBQUMsQ0FBQyxDQUFDO0lBRUosT0FBTztRQUNMLFVBQVUsRUFBRSxHQUFHO1FBQ2YsT0FBTztRQUNQLElBQUksRUFBRSxJQUFJLENBQUMsU0FBUyxDQUFDO1lBQ25CLFVBQVUsRUFBRSxTQUFTO1lBQ3JCLEtBQUs7WUFDTCxLQUFLLEVBQUUsTUFBTSxDQUFDLE1BQU07WUFDcEIsTUFBTTtTQUNQLENBQUM7S0FDSCxDQUFDO0FBQ0osQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogVGVsZW1ldHJ5IEFQSSBMYW1iZGFcbiAqXG4gKiBRdWVyaWVzIER5bmFtb0RCIGZvciBkZXZpY2UgdGVsZW1ldHJ5IGRhdGE6XG4gKiAtIEdFVCAvZGV2aWNlcy97ZGV2aWNlX3VpZH0vdGVsZW1ldHJ5IC0gR2V0IHRlbGVtZXRyeSBoaXN0b3J5XG4gKiAtIEdFVCAvZGV2aWNlcy97ZGV2aWNlX3VpZH0vbG9jYXRpb24gLSBHZXQgbG9jYXRpb24gaGlzdG9yeVxuICogLSBHRVQgL2RldmljZXMve2RldmljZV91aWR9L3Bvd2VyIC0gR2V0IE1vam8gcG93ZXIgaGlzdG9yeVxuICogLSBHRVQgL2RldmljZXMve2RldmljZV91aWR9L2hlYWx0aCAtIEdldCBoZWFsdGggZXZlbnQgaGlzdG9yeVxuICovXG5cbmltcG9ydCB7IER5bmFtb0RCQ2xpZW50IH0gZnJvbSAnQGF3cy1zZGsvY2xpZW50LWR5bmFtb2RiJztcbmltcG9ydCB7IER5bmFtb0RCRG9jdW1lbnRDbGllbnQsIFF1ZXJ5Q29tbWFuZCB9IGZyb20gJ0Bhd3Mtc2RrL2xpYi1keW5hbW9kYic7XG5pbXBvcnQgeyBBUElHYXRld2F5UHJveHlFdmVudCwgQVBJR2F0ZXdheVByb3h5UmVzdWx0IH0gZnJvbSAnYXdzLWxhbWJkYSc7XG5cbmNvbnN0IGRkYkNsaWVudCA9IG5ldyBEeW5hbW9EQkNsaWVudCh7fSk7XG5jb25zdCBkb2NDbGllbnQgPSBEeW5hbW9EQkRvY3VtZW50Q2xpZW50LmZyb20oZGRiQ2xpZW50KTtcblxuY29uc3QgVEVMRU1FVFJZX1RBQkxFID0gcHJvY2Vzcy5lbnYuVEVMRU1FVFJZX1RBQkxFITtcblxuZXhwb3J0IGNvbnN0IGhhbmRsZXIgPSBhc3luYyAoZXZlbnQ6IEFQSUdhdGV3YXlQcm94eUV2ZW50KTogUHJvbWlzZTxBUElHYXRld2F5UHJveHlSZXN1bHQ+ID0+IHtcbiAgY29uc29sZS5sb2coJ1JlcXVlc3Q6JywgSlNPTi5zdHJpbmdpZnkoZXZlbnQpKTtcblxuICBjb25zdCBjb3JzSGVhZGVycyA9IHtcbiAgICAnQWNjZXNzLUNvbnRyb2wtQWxsb3ctT3JpZ2luJzogJyonLFxuICAgICdBY2Nlc3MtQ29udHJvbC1BbGxvdy1IZWFkZXJzJzogJ0NvbnRlbnQtVHlwZSxBdXRob3JpemF0aW9uJyxcbiAgICAnQWNjZXNzLUNvbnRyb2wtQWxsb3ctTWV0aG9kcyc6ICdHRVQsT1BUSU9OUycsXG4gIH07XG5cbiAgdHJ5IHtcbiAgICAvLyBIVFRQIEFQSSB2MiB1c2VzIHJlcXVlc3RDb250ZXh0Lmh0dHAubWV0aG9kLCBSRVNUIEFQSSB2MSB1c2VzIGh0dHBNZXRob2RcbiAgICBjb25zdCBtZXRob2QgPSAoZXZlbnQucmVxdWVzdENvbnRleHQgYXMgYW55KT8uaHR0cD8ubWV0aG9kIHx8IGV2ZW50Lmh0dHBNZXRob2Q7XG4gICAgY29uc3QgcGF0aCA9IChldmVudC5yZXF1ZXN0Q29udGV4dCBhcyBhbnkpPy5odHRwPy5wYXRoIHx8IGV2ZW50LnBhdGg7XG5cbiAgICBpZiAobWV0aG9kID09PSAnT1BUSU9OUycpIHtcbiAgICAgIHJldHVybiB7IHN0YXR1c0NvZGU6IDIwMCwgaGVhZGVyczogY29yc0hlYWRlcnMsIGJvZHk6ICcnIH07XG4gICAgfVxuXG4gICAgY29uc3QgZGV2aWNlVWlkID0gZXZlbnQucGF0aFBhcmFtZXRlcnM/LmRldmljZV91aWQ7XG4gICAgaWYgKCFkZXZpY2VVaWQpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN0YXR1c0NvZGU6IDQwMCxcbiAgICAgICAgaGVhZGVyczogY29yc0hlYWRlcnMsXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHsgZXJyb3I6ICdkZXZpY2VfdWlkIHJlcXVpcmVkJyB9KSxcbiAgICAgIH07XG4gICAgfVxuXG4gICAgY29uc3QgcXVlcnlQYXJhbXMgPSBldmVudC5xdWVyeVN0cmluZ1BhcmFtZXRlcnMgfHwge307XG5cbiAgICAvLyBQYXJzZSB0aW1lIHJhbmdlXG4gICAgY29uc3QgaG91cnMgPSBwYXJzZUludChxdWVyeVBhcmFtcy5ob3VycyB8fCAnMjQnKTtcbiAgICBjb25zdCBsaW1pdCA9IHBhcnNlSW50KHF1ZXJ5UGFyYW1zLmxpbWl0IHx8ICcxMDAwJyk7XG5cbiAgICBpZiAocGF0aC5lbmRzV2l0aCgnL2xvY2F0aW9uJykpIHtcbiAgICAgIHJldHVybiBhd2FpdCBnZXRMb2NhdGlvbkhpc3RvcnkoZGV2aWNlVWlkLCBob3VycywgbGltaXQsIGNvcnNIZWFkZXJzKTtcbiAgICB9XG5cbiAgICBpZiAocGF0aC5lbmRzV2l0aCgnL3Bvd2VyJykpIHtcbiAgICAgIHJldHVybiBhd2FpdCBnZXRQb3dlckhpc3RvcnkoZGV2aWNlVWlkLCBob3VycywgbGltaXQsIGNvcnNIZWFkZXJzKTtcbiAgICB9XG5cbiAgICBpZiAocGF0aC5lbmRzV2l0aCgnL2hlYWx0aCcpKSB7XG4gICAgICByZXR1cm4gYXdhaXQgZ2V0SGVhbHRoSGlzdG9yeShkZXZpY2VVaWQsIGhvdXJzLCBsaW1pdCwgY29yc0hlYWRlcnMpO1xuICAgIH1cblxuICAgIHJldHVybiBhd2FpdCBnZXRUZWxlbWV0cnlIaXN0b3J5KGRldmljZVVpZCwgaG91cnMsIGxpbWl0LCBjb3JzSGVhZGVycyk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3I6JywgZXJyb3IpO1xuICAgIHJldHVybiB7XG4gICAgICBzdGF0dXNDb2RlOiA1MDAsXG4gICAgICBoZWFkZXJzOiBjb3JzSGVhZGVycyxcbiAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHsgZXJyb3I6ICdJbnRlcm5hbCBzZXJ2ZXIgZXJyb3InIH0pLFxuICAgIH07XG4gIH1cbn07XG5cbmFzeW5jIGZ1bmN0aW9uIGdldFRlbGVtZXRyeUhpc3RvcnkoXG4gIGRldmljZVVpZDogc3RyaW5nLFxuICBob3VyczogbnVtYmVyLFxuICBsaW1pdDogbnVtYmVyLFxuICBoZWFkZXJzOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+XG4pOiBQcm9taXNlPEFQSUdhdGV3YXlQcm94eVJlc3VsdD4ge1xuICBjb25zdCBjdXRvZmZUaW1lID0gRGF0ZS5ub3coKSAtIChob3VycyAqIDYwICogNjAgKiAxMDAwKTtcblxuICAvLyBVc2UgdGhlIGV2ZW50LXR5cGUtaW5kZXggR1NJIHRvIGVmZmljaWVudGx5IHF1ZXJ5IGJ5IGRhdGFfdHlwZVxuICAvLyBUaGUgc29ydCBrZXkgaXMgZm9ybWF0dGVkIGFzIHtkYXRhX3R5cGV9I3t0aW1lc3RhbXB9XG4gIGNvbnN0IGN1dG9mZktleSA9IGB0ZWxlbWV0cnkjJHtjdXRvZmZUaW1lfWA7XG4gIGNvbnN0IGVuZEtleSA9IGB0ZWxlbWV0cnkjJHtEYXRlLm5vdygpICsgMTAwMH1gOyAvLyBTbGlnaHRseSBpbiBmdXR1cmUgdG8gaW5jbHVkZSBsYXRlc3RcblxuICAvLyBGb3IgaGlnaGVyIGxpbWl0cywgZmV0Y2ggYWxsIGRhdGEgaW4gcmFuZ2UgdGhlbiBhcHBseSBsaW1pdCBhdCB0aGUgZW5kXG4gIC8vIFRoaXMgZW5zdXJlcyB3ZSBnZXQgdGhlIGNvbXBsZXRlIHRpbWUgcmFuZ2UsIG5vdCBqdXN0IHRoZSBOIG1vc3QgcmVjZW50XG4gIGNvbnN0IGZldGNoQWxsID0gbGltaXQgPiAxMDAwO1xuXG4gIGxldCBhbGxJdGVtczogUmVjb3JkPHN0cmluZywgYW55PltdID0gW107XG4gIGxldCBsYXN0RXZhbHVhdGVkS2V5OiBSZWNvcmQ8c3RyaW5nLCBhbnk+IHwgdW5kZWZpbmVkO1xuXG4gIGRvIHtcbiAgICBjb25zdCBjb21tYW5kID0gbmV3IFF1ZXJ5Q29tbWFuZCh7XG4gICAgICBUYWJsZU5hbWU6IFRFTEVNRVRSWV9UQUJMRSxcbiAgICAgIEluZGV4TmFtZTogJ2V2ZW50LXR5cGUtaW5kZXgnLFxuICAgICAgS2V5Q29uZGl0aW9uRXhwcmVzc2lvbjogJ2RldmljZV91aWQgPSA6ZGV2aWNlX3VpZCBBTkQgZXZlbnRfdHlwZV90aW1lc3RhbXAgQkVUV0VFTiA6c3RhcnQgQU5EIDplbmQnLFxuICAgICAgRXhwcmVzc2lvbkF0dHJpYnV0ZVZhbHVlczoge1xuICAgICAgICAnOmRldmljZV91aWQnOiBkZXZpY2VVaWQsXG4gICAgICAgICc6c3RhcnQnOiBjdXRvZmZLZXksXG4gICAgICAgICc6ZW5kJzogZW5kS2V5LFxuICAgICAgfSxcbiAgICAgIFNjYW5JbmRleEZvcndhcmQ6IHRydWUsIC8vIENocm9ub2xvZ2ljYWwgb3JkZXIgKG9sZGVzdCBmaXJzdClcbiAgICAgIC4uLihmZXRjaEFsbCA/IHt9IDogeyBMaW1pdDogbGltaXQgfSksXG4gICAgICAuLi4obGFzdEV2YWx1YXRlZEtleSA/IHsgRXhjbHVzaXZlU3RhcnRLZXk6IGxhc3RFdmFsdWF0ZWRLZXkgfSA6IHt9KSxcbiAgICB9KTtcblxuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGRvY0NsaWVudC5zZW5kKGNvbW1hbmQpO1xuICAgIGFsbEl0ZW1zID0gYWxsSXRlbXMuY29uY2F0KHJlc3VsdC5JdGVtcyB8fCBbXSk7XG4gICAgbGFzdEV2YWx1YXRlZEtleSA9IHJlc3VsdC5MYXN0RXZhbHVhdGVkS2V5O1xuXG4gICAgLy8gU3RvcCBpZiB3ZSBoYXZlIGVub3VnaCBpdGVtcyBvciBpZiBmZXRjaEFsbCBpcyBmYWxzZVxuICAgIGlmICghZmV0Y2hBbGwgfHwgYWxsSXRlbXMubGVuZ3RoID49IGxpbWl0KSBicmVhaztcbiAgfSB3aGlsZSAobGFzdEV2YWx1YXRlZEtleSk7XG5cbiAgLy8gQXBwbHkgbGltaXQgYW5kIHJldmVyc2UgdG8gZ2V0IG5ld2VzdC1maXJzdCBvcmRlciBmb3IgZnJvbnRlbmRcbiAgY29uc3QgaXRlbXMgPSBhbGxJdGVtcy5zbGljZSgtbGltaXQpLnJldmVyc2UoKTtcblxuICAvLyBUcmFuc2Zvcm0gdG8gQVBJIHJlc3BvbnNlIGZvcm1hdFxuICAvLyBOb3RlOiB2b2x0YWdlIGlzIG5vIGxvbmdlciBpbmNsdWRlZCBpbiB0cmFjay5xbyB0ZWxlbWV0cnk7IGJhdHRlcnkgaW5mbyBjb21lcyBmcm9tIHBvd2VyIEFQSVxuICBjb25zdCB0ZWxlbWV0cnkgPSBpdGVtcy5tYXAoKGl0ZW0pID0+ICh7XG4gICAgdGltZTogbmV3IERhdGUoaXRlbS50aW1lc3RhbXApLnRvSVNPU3RyaW5nKCksXG4gICAgdGVtcGVyYXR1cmU6IGl0ZW0udGVtcGVyYXR1cmUsXG4gICAgaHVtaWRpdHk6IGl0ZW0uaHVtaWRpdHksXG4gICAgcHJlc3N1cmU6IGl0ZW0ucHJlc3N1cmUsXG4gICAgbW90aW9uOiBpdGVtLm1vdGlvbixcbiAgfSkpO1xuXG4gIHJldHVybiB7XG4gICAgc3RhdHVzQ29kZTogMjAwLFxuICAgIGhlYWRlcnMsXG4gICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgZGV2aWNlX3VpZDogZGV2aWNlVWlkLFxuICAgICAgaG91cnMsXG4gICAgICBjb3VudDogdGVsZW1ldHJ5Lmxlbmd0aCxcbiAgICAgIHRlbGVtZXRyeSxcbiAgICB9KSxcbiAgfTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gZ2V0TG9jYXRpb25IaXN0b3J5KFxuICBkZXZpY2VVaWQ6IHN0cmluZyxcbiAgaG91cnM6IG51bWJlcixcbiAgbGltaXQ6IG51bWJlcixcbiAgaGVhZGVyczogUmVjb3JkPHN0cmluZywgc3RyaW5nPlxuKTogUHJvbWlzZTxBUElHYXRld2F5UHJveHlSZXN1bHQ+IHtcbiAgY29uc3QgY3V0b2ZmVGltZSA9IERhdGUubm93KCkgLSAoaG91cnMgKiA2MCAqIDYwICogMTAwMCk7XG5cbiAgLy8gVXNlIHRoZSBldmVudC10eXBlLWluZGV4IEdTSSB0byBlZmZpY2llbnRseSBxdWVyeSB0ZWxlbWV0cnkgcmVjb3Jkc1xuICBjb25zdCBjdXRvZmZLZXkgPSBgdGVsZW1ldHJ5IyR7Y3V0b2ZmVGltZX1gO1xuICBjb25zdCBlbmRLZXkgPSBgdGVsZW1ldHJ5IyR7RGF0ZS5ub3coKSArIDEwMDB9YDtcblxuICBjb25zdCBjb21tYW5kID0gbmV3IFF1ZXJ5Q29tbWFuZCh7XG4gICAgVGFibGVOYW1lOiBURUxFTUVUUllfVEFCTEUsXG4gICAgSW5kZXhOYW1lOiAnZXZlbnQtdHlwZS1pbmRleCcsXG4gICAgS2V5Q29uZGl0aW9uRXhwcmVzc2lvbjogJ2RldmljZV91aWQgPSA6ZGV2aWNlX3VpZCBBTkQgZXZlbnRfdHlwZV90aW1lc3RhbXAgQkVUV0VFTiA6c3RhcnQgQU5EIDplbmQnLFxuICAgIEZpbHRlckV4cHJlc3Npb246ICdhdHRyaWJ1dGVfZXhpc3RzKGxhdGl0dWRlKScsXG4gICAgRXhwcmVzc2lvbkF0dHJpYnV0ZVZhbHVlczoge1xuICAgICAgJzpkZXZpY2VfdWlkJzogZGV2aWNlVWlkLFxuICAgICAgJzpzdGFydCc6IGN1dG9mZktleSxcbiAgICAgICc6ZW5kJzogZW5kS2V5LFxuICAgIH0sXG4gICAgU2NhbkluZGV4Rm9yd2FyZDogZmFsc2UsIC8vIE5ld2VzdCBmaXJzdFxuICAgIExpbWl0OiBsaW1pdCxcbiAgfSk7XG5cbiAgY29uc3QgcmVzdWx0ID0gYXdhaXQgZG9jQ2xpZW50LnNlbmQoY29tbWFuZCk7XG5cbiAgLy8gVHJhbnNmb3JtIHRvIEFQSSByZXNwb25zZSBmb3JtYXRcbiAgY29uc3QgbG9jYXRpb25zID0gKHJlc3VsdC5JdGVtcyB8fCBbXSlcbiAgICAuZmlsdGVyKChpdGVtKSA9PiBpdGVtLmxhdGl0dWRlICE9PSB1bmRlZmluZWQgJiYgaXRlbS5sb25naXR1ZGUgIT09IHVuZGVmaW5lZClcbiAgICAubWFwKChpdGVtKSA9PiAoe1xuICAgICAgdGltZTogbmV3IERhdGUoaXRlbS50aW1lc3RhbXApLnRvSVNPU3RyaW5nKCksXG4gICAgICBsYXQ6IGl0ZW0ubGF0aXR1ZGUsXG4gICAgICBsb246IGl0ZW0ubG9uZ2l0dWRlLFxuICAgICAgc291cmNlOiBpdGVtLmxvY2F0aW9uX3NvdXJjZSxcbiAgICB9KSk7XG5cbiAgcmV0dXJuIHtcbiAgICBzdGF0dXNDb2RlOiAyMDAsXG4gICAgaGVhZGVycyxcbiAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICBkZXZpY2VfdWlkOiBkZXZpY2VVaWQsXG4gICAgICBob3VycyxcbiAgICAgIGNvdW50OiBsb2NhdGlvbnMubGVuZ3RoLFxuICAgICAgbG9jYXRpb25zLFxuICAgIH0pLFxuICB9O1xufVxuXG5hc3luYyBmdW5jdGlvbiBnZXRQb3dlckhpc3RvcnkoXG4gIGRldmljZVVpZDogc3RyaW5nLFxuICBob3VyczogbnVtYmVyLFxuICBsaW1pdDogbnVtYmVyLFxuICBoZWFkZXJzOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+XG4pOiBQcm9taXNlPEFQSUdhdGV3YXlQcm94eVJlc3VsdD4ge1xuICBjb25zdCBjdXRvZmZUaW1lID0gRGF0ZS5ub3coKSAtIChob3VycyAqIDYwICogNjAgKiAxMDAwKTtcblxuICAvLyBVc2UgdGhlIGV2ZW50LXR5cGUtaW5kZXggR1NJIHRvIGVmZmljaWVudGx5IHF1ZXJ5IHBvd2VyIHJlY29yZHNcbiAgY29uc3QgY3V0b2ZmS2V5ID0gYHBvd2VyIyR7Y3V0b2ZmVGltZX1gO1xuICBjb25zdCBlbmRLZXkgPSBgcG93ZXIjJHtEYXRlLm5vdygpICsgMTAwMH1gO1xuXG4gIGNvbnN0IGNvbW1hbmQgPSBuZXcgUXVlcnlDb21tYW5kKHtcbiAgICBUYWJsZU5hbWU6IFRFTEVNRVRSWV9UQUJMRSxcbiAgICBJbmRleE5hbWU6ICdldmVudC10eXBlLWluZGV4JyxcbiAgICBLZXlDb25kaXRpb25FeHByZXNzaW9uOiAnZGV2aWNlX3VpZCA9IDpkZXZpY2VfdWlkIEFORCBldmVudF90eXBlX3RpbWVzdGFtcCBCRVRXRUVOIDpzdGFydCBBTkQgOmVuZCcsXG4gICAgRXhwcmVzc2lvbkF0dHJpYnV0ZVZhbHVlczoge1xuICAgICAgJzpkZXZpY2VfdWlkJzogZGV2aWNlVWlkLFxuICAgICAgJzpzdGFydCc6IGN1dG9mZktleSxcbiAgICAgICc6ZW5kJzogZW5kS2V5LFxuICAgIH0sXG4gICAgU2NhbkluZGV4Rm9yd2FyZDogZmFsc2UsIC8vIE5ld2VzdCBmaXJzdFxuICAgIExpbWl0OiBsaW1pdCxcbiAgfSk7XG5cbiAgY29uc3QgcmVzdWx0ID0gYXdhaXQgZG9jQ2xpZW50LnNlbmQoY29tbWFuZCk7XG5cbiAgLy8gVHJhbnNmb3JtIHRvIEFQSSByZXNwb25zZSBmb3JtYXRcbiAgY29uc3QgcG93ZXIgPSAocmVzdWx0Lkl0ZW1zIHx8IFtdKS5tYXAoKGl0ZW0pID0+ICh7XG4gICAgdGltZTogbmV3IERhdGUoaXRlbS50aW1lc3RhbXApLnRvSVNPU3RyaW5nKCksXG4gICAgdm9sdGFnZTogaXRlbS5tb2pvX3ZvbHRhZ2UsXG4gICAgbWlsbGlhbXBfaG91cnM6IGl0ZW0ubWlsbGlhbXBfaG91cnMsXG4gIH0pKTtcblxuICByZXR1cm4ge1xuICAgIHN0YXR1c0NvZGU6IDIwMCxcbiAgICBoZWFkZXJzLFxuICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgIGRldmljZV91aWQ6IGRldmljZVVpZCxcbiAgICAgIGhvdXJzLFxuICAgICAgY291bnQ6IHBvd2VyLmxlbmd0aCxcbiAgICAgIHBvd2VyLFxuICAgIH0pLFxuICB9O1xufVxuXG5hc3luYyBmdW5jdGlvbiBnZXRIZWFsdGhIaXN0b3J5KFxuICBkZXZpY2VVaWQ6IHN0cmluZyxcbiAgaG91cnM6IG51bWJlcixcbiAgbGltaXQ6IG51bWJlcixcbiAgaGVhZGVyczogUmVjb3JkPHN0cmluZywgc3RyaW5nPlxuKTogUHJvbWlzZTxBUElHYXRld2F5UHJveHlSZXN1bHQ+IHtcbiAgY29uc3QgY3V0b2ZmVGltZSA9IERhdGUubm93KCkgLSAoaG91cnMgKiA2MCAqIDYwICogMTAwMCk7XG5cbiAgLy8gVXNlIHRoZSBldmVudC10eXBlLWluZGV4IEdTSSB0byBlZmZpY2llbnRseSBxdWVyeSBoZWFsdGggcmVjb3Jkc1xuICBjb25zdCBjdXRvZmZLZXkgPSBgaGVhbHRoIyR7Y3V0b2ZmVGltZX1gO1xuICBjb25zdCBlbmRLZXkgPSBgaGVhbHRoIyR7RGF0ZS5ub3coKSArIDEwMDB9YDtcblxuICBjb25zdCBjb21tYW5kID0gbmV3IFF1ZXJ5Q29tbWFuZCh7XG4gICAgVGFibGVOYW1lOiBURUxFTUVUUllfVEFCTEUsXG4gICAgSW5kZXhOYW1lOiAnZXZlbnQtdHlwZS1pbmRleCcsXG4gICAgS2V5Q29uZGl0aW9uRXhwcmVzc2lvbjogJ2RldmljZV91aWQgPSA6ZGV2aWNlX3VpZCBBTkQgZXZlbnRfdHlwZV90aW1lc3RhbXAgQkVUV0VFTiA6c3RhcnQgQU5EIDplbmQnLFxuICAgIEV4cHJlc3Npb25BdHRyaWJ1dGVWYWx1ZXM6IHtcbiAgICAgICc6ZGV2aWNlX3VpZCc6IGRldmljZVVpZCxcbiAgICAgICc6c3RhcnQnOiBjdXRvZmZLZXksXG4gICAgICAnOmVuZCc6IGVuZEtleSxcbiAgICB9LFxuICAgIFNjYW5JbmRleEZvcndhcmQ6IGZhbHNlLCAvLyBOZXdlc3QgZmlyc3RcbiAgICBMaW1pdDogbGltaXQsXG4gIH0pO1xuXG4gIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGRvY0NsaWVudC5zZW5kKGNvbW1hbmQpO1xuXG4gIC8vIFRyYW5zZm9ybSB0byBBUEkgcmVzcG9uc2UgZm9ybWF0XG4gIGNvbnN0IGhlYWx0aCA9IChyZXN1bHQuSXRlbXMgfHwgW10pLm1hcCgoaXRlbSkgPT4gKHtcbiAgICB0aW1lOiBuZXcgRGF0ZShpdGVtLnRpbWVzdGFtcCkudG9JU09TdHJpbmcoKSxcbiAgICBtZXRob2Q6IGl0ZW0ubWV0aG9kLFxuICAgIHRleHQ6IGl0ZW0udGV4dCxcbiAgICB2b2x0YWdlOiBpdGVtLnZvbHRhZ2UsXG4gICAgdm9sdGFnZV9tb2RlOiBpdGVtLnZvbHRhZ2VfbW9kZSxcbiAgICBtaWxsaWFtcF9ob3VyczogaXRlbS5taWxsaWFtcF9ob3VycyxcbiAgfSkpO1xuXG4gIHJldHVybiB7XG4gICAgc3RhdHVzQ29kZTogMjAwLFxuICAgIGhlYWRlcnMsXG4gICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgZGV2aWNlX3VpZDogZGV2aWNlVWlkLFxuICAgICAgaG91cnMsXG4gICAgICBjb3VudDogaGVhbHRoLmxlbmd0aCxcbiAgICAgIGhlYWx0aCxcbiAgICB9KSxcbiAgfTtcbn1cbiJdfQ==