"use strict";
/**
 * Telemetry API Lambda
 *
 * Queries DynamoDB for device telemetry data:
 * - GET /devices/{device_uid}/telemetry - Get telemetry history
 * - GET /devices/{device_uid}/location - Get location history
 * - GET /devices/{device_uid}/power - Get Mojo power history
 * - GET /devices/{device_uid}/health - Get health event history
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.handler = void 0;
const client_dynamodb_1 = require("@aws-sdk/client-dynamodb");
const lib_dynamodb_1 = require("@aws-sdk/lib-dynamodb");
const ddbClient = new client_dynamodb_1.DynamoDBClient({});
const docClient = lib_dynamodb_1.DynamoDBDocumentClient.from(ddbClient);
const TELEMETRY_TABLE = process.env.TELEMETRY_TABLE;
const handler = async (event) => {
    console.log('Request:', JSON.stringify(event));
    const corsHeaders = {
        'Access-Control-Allow-Origin': '*',
        'Access-Control-Allow-Headers': 'Content-Type,Authorization',
        'Access-Control-Allow-Methods': 'GET,OPTIONS',
    };
    try {
        // HTTP API v2 uses requestContext.http.method, REST API v1 uses httpMethod
        const method = event.requestContext?.http?.method || event.httpMethod;
        const path = event.requestContext?.http?.path || event.path;
        if (method === 'OPTIONS') {
            return { statusCode: 200, headers: corsHeaders, body: '' };
        }
        const deviceUid = event.pathParameters?.device_uid;
        if (!deviceUid) {
            return {
                statusCode: 400,
                headers: corsHeaders,
                body: JSON.stringify({ error: 'device_uid required' }),
            };
        }
        const queryParams = event.queryStringParameters || {};
        // Parse time range
        const hours = parseInt(queryParams.hours || '24');
        const limit = parseInt(queryParams.limit || '1000');
        if (path.endsWith('/location')) {
            return await getLocationHistory(deviceUid, hours, limit, corsHeaders);
        }
        if (path.endsWith('/power')) {
            return await getPowerHistory(deviceUid, hours, limit, corsHeaders);
        }
        if (path.endsWith('/health')) {
            return await getHealthHistory(deviceUid, hours, limit, corsHeaders);
        }
        return await getTelemetryHistory(deviceUid, hours, limit, corsHeaders);
    }
    catch (error) {
        console.error('Error:', error);
        return {
            statusCode: 500,
            headers: corsHeaders,
            body: JSON.stringify({ error: 'Internal server error' }),
        };
    }
};
exports.handler = handler;
async function getTelemetryHistory(deviceUid, hours, limit, headers) {
    const cutoffTime = Date.now() - (hours * 60 * 60 * 1000);
    // Use the event-type-index GSI to efficiently query by data_type
    // The sort key is formatted as {data_type}#{timestamp}
    const cutoffKey = `telemetry#${cutoffTime}`;
    const endKey = `telemetry#${Date.now() + 1000}`; // Slightly in future to include latest
    const command = new lib_dynamodb_1.QueryCommand({
        TableName: TELEMETRY_TABLE,
        IndexName: 'event-type-index',
        KeyConditionExpression: 'device_uid = :device_uid AND event_type_timestamp BETWEEN :start AND :end',
        ExpressionAttributeValues: {
            ':device_uid': deviceUid,
            ':start': cutoffKey,
            ':end': endKey,
        },
        ScanIndexForward: false, // Newest first
        Limit: limit,
    });
    const result = await docClient.send(command);
    // Transform to API response format
    const telemetry = (result.Items || []).map((item) => ({
        time: new Date(item.timestamp).toISOString(),
        temperature: item.temperature,
        humidity: item.humidity,
        pressure: item.pressure,
        voltage: item.voltage,
        motion: item.motion,
    }));
    return {
        statusCode: 200,
        headers,
        body: JSON.stringify({
            device_uid: deviceUid,
            hours,
            count: telemetry.length,
            telemetry,
        }),
    };
}
async function getLocationHistory(deviceUid, hours, limit, headers) {
    const cutoffTime = Date.now() - (hours * 60 * 60 * 1000);
    // Use the event-type-index GSI to efficiently query telemetry records
    const cutoffKey = `telemetry#${cutoffTime}`;
    const endKey = `telemetry#${Date.now() + 1000}`;
    const command = new lib_dynamodb_1.QueryCommand({
        TableName: TELEMETRY_TABLE,
        IndexName: 'event-type-index',
        KeyConditionExpression: 'device_uid = :device_uid AND event_type_timestamp BETWEEN :start AND :end',
        FilterExpression: 'attribute_exists(latitude)',
        ExpressionAttributeValues: {
            ':device_uid': deviceUid,
            ':start': cutoffKey,
            ':end': endKey,
        },
        ScanIndexForward: false, // Newest first
        Limit: limit,
    });
    const result = await docClient.send(command);
    // Transform to API response format
    const locations = (result.Items || [])
        .filter((item) => item.latitude !== undefined && item.longitude !== undefined)
        .map((item) => ({
        time: new Date(item.timestamp).toISOString(),
        lat: item.latitude,
        lon: item.longitude,
        source: item.location_source,
    }));
    return {
        statusCode: 200,
        headers,
        body: JSON.stringify({
            device_uid: deviceUid,
            hours,
            count: locations.length,
            locations,
        }),
    };
}
async function getPowerHistory(deviceUid, hours, limit, headers) {
    const cutoffTime = Date.now() - (hours * 60 * 60 * 1000);
    // Use the event-type-index GSI to efficiently query power records
    const cutoffKey = `power#${cutoffTime}`;
    const endKey = `power#${Date.now() + 1000}`;
    const command = new lib_dynamodb_1.QueryCommand({
        TableName: TELEMETRY_TABLE,
        IndexName: 'event-type-index',
        KeyConditionExpression: 'device_uid = :device_uid AND event_type_timestamp BETWEEN :start AND :end',
        ExpressionAttributeValues: {
            ':device_uid': deviceUid,
            ':start': cutoffKey,
            ':end': endKey,
        },
        ScanIndexForward: false, // Newest first
        Limit: limit,
    });
    const result = await docClient.send(command);
    // Transform to API response format
    const power = (result.Items || []).map((item) => ({
        time: new Date(item.timestamp).toISOString(),
        voltage: item.mojo_voltage,
        milliamp_hours: item.milliamp_hours,
    }));
    return {
        statusCode: 200,
        headers,
        body: JSON.stringify({
            device_uid: deviceUid,
            hours,
            count: power.length,
            power,
        }),
    };
}
async function getHealthHistory(deviceUid, hours, limit, headers) {
    const cutoffTime = Date.now() - (hours * 60 * 60 * 1000);
    // Use the event-type-index GSI to efficiently query health records
    const cutoffKey = `health#${cutoffTime}`;
    const endKey = `health#${Date.now() + 1000}`;
    const command = new lib_dynamodb_1.QueryCommand({
        TableName: TELEMETRY_TABLE,
        IndexName: 'event-type-index',
        KeyConditionExpression: 'device_uid = :device_uid AND event_type_timestamp BETWEEN :start AND :end',
        ExpressionAttributeValues: {
            ':device_uid': deviceUid,
            ':start': cutoffKey,
            ':end': endKey,
        },
        ScanIndexForward: false, // Newest first
        Limit: limit,
    });
    const result = await docClient.send(command);
    // Transform to API response format
    const health = (result.Items || []).map((item) => ({
        time: new Date(item.timestamp).toISOString(),
        method: item.method,
        text: item.text,
        voltage: item.voltage,
        voltage_mode: item.voltage_mode,
        milliamp_hours: item.milliamp_hours,
    }));
    return {
        statusCode: 200,
        headers,
        body: JSON.stringify({
            device_uid: deviceUid,
            hours,
            count: health.length,
            health,
        }),
    };
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi9sYW1iZGEvYXBpLXRlbGVtZXRyeS9pbmRleC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUE7Ozs7Ozs7O0dBUUc7OztBQUVILDhEQUEwRDtBQUMxRCx3REFBNkU7QUFHN0UsTUFBTSxTQUFTLEdBQUcsSUFBSSxnQ0FBYyxDQUFDLEVBQUUsQ0FBQyxDQUFDO0FBQ3pDLE1BQU0sU0FBUyxHQUFHLHFDQUFzQixDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQztBQUV6RCxNQUFNLGVBQWUsR0FBRyxPQUFPLENBQUMsR0FBRyxDQUFDLGVBQWdCLENBQUM7QUFFOUMsTUFBTSxPQUFPLEdBQUcsS0FBSyxFQUFFLEtBQTJCLEVBQWtDLEVBQUU7SUFDM0YsT0FBTyxDQUFDLEdBQUcsQ0FBQyxVQUFVLEVBQUUsSUFBSSxDQUFDLFNBQVMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDO0lBRS9DLE1BQU0sV0FBVyxHQUFHO1FBQ2xCLDZCQUE2QixFQUFFLEdBQUc7UUFDbEMsOEJBQThCLEVBQUUsNEJBQTRCO1FBQzVELDhCQUE4QixFQUFFLGFBQWE7S0FDOUMsQ0FBQztJQUVGLElBQUksQ0FBQztRQUNILDJFQUEyRTtRQUMzRSxNQUFNLE1BQU0sR0FBSSxLQUFLLENBQUMsY0FBc0IsRUFBRSxJQUFJLEVBQUUsTUFBTSxJQUFJLEtBQUssQ0FBQyxVQUFVLENBQUM7UUFDL0UsTUFBTSxJQUFJLEdBQUksS0FBSyxDQUFDLGNBQXNCLEVBQUUsSUFBSSxFQUFFLElBQUksSUFBSSxLQUFLLENBQUMsSUFBSSxDQUFDO1FBRXJFLElBQUksTUFBTSxLQUFLLFNBQVMsRUFBRSxDQUFDO1lBQ3pCLE9BQU8sRUFBRSxVQUFVLEVBQUUsR0FBRyxFQUFFLE9BQU8sRUFBRSxXQUFXLEVBQUUsSUFBSSxFQUFFLEVBQUUsRUFBRSxDQUFDO1FBQzdELENBQUM7UUFFRCxNQUFNLFNBQVMsR0FBRyxLQUFL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QUFDLE9BQU87UUFDckIsWUFBWSxFQUFFLElBQUksQ0FBQyxZQUFZO1FBQy9CLGNBQWMsRUFBRSxJQUFJLENBQUMsY0FBYztLQUNwQyxDQUFDLENBQUMsQ0FBQztJQUVKLE9BQU87UUFDTCxVQUFVLEVBQUUsR0FBRztRQUNmLE9BQU87UUFDUCxJQUFJLEVBQUUsSUFBSSxDQUFDLFNBQVMsQ0FBQztZQUNuQixVQUFVLEVBQUUsU0FBUztZQUNyQixLQUFLO1lBQ0wsS0FBSyxFQUFFLE1BQU0sQ0FBQyxNQUFNO1lBQ3BCLE1BQU07U0FDUCxDQUFDO0tBQ0gsQ0FBQztBQUNKLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFRlbGVtZXRyeSBBUEkgTGFtYmRhXG4gKlxuICogUXVlcmllcyBEeW5hbW9EQiBmb3IgZGV2aWNlIHRlbGVtZXRyeSBkYXRhOlxuICogLSBHRVQgL2RldmljZXMve2RldmljZV91aWR9L3RlbGVtZXRyeSAtIEdldCB0ZWxlbWV0cnkgaGlzdG9yeVxuICogLSBHRVQgL2RldmljZXMve2RldmljZV91aWR9L2xvY2F0aW9uIC0gR2V0IGxvY2F0aW9uIGhpc3RvcnlcbiAqIC0gR0VUIC9kZXZpY2VzL3tkZXZpY2VfdWlkfS9wb3dlciAtIEdldCBNb2pvIHBvd2VyIGhpc3RvcnlcbiAqIC0gR0VUIC9kZXZpY2VzL3tkZXZpY2VfdWlkfS9oZWFsdGggLSBHZXQgaGVhbHRoIGV2ZW50IGhpc3RvcnlcbiAqL1xuXG5pbXBvcnQgeyBEeW5hbW9EQkNsaWVudCB9IGZyb20gJ0Bhd3Mtc2RrL2NsaWVudC1keW5hbW9kYic7XG5pbXBvcnQgeyBEeW5hbW9EQkRvY3VtZW50Q2xpZW50LCBRdWVyeUNvbW1hbmQgfSBmcm9tICdAYXdzLXNkay9saWItZHluYW1vZGInO1xuaW1wb3J0IHsgQVBJR2F0ZXdheVByb3h5RXZlbnQsIEFQSUdhdGV3YXlQcm94eVJlc3VsdCB9IGZyb20gJ2F3cy1sYW1iZGEnO1xuXG5jb25zdCBkZGJDbGllbnQgPSBuZXcgRHluYW1vREJDbGllbnQoe30pO1xuY29uc3QgZG9jQ2xpZW50ID0gRHluYW1vREJEb2N1bWVudENsaWVudC5mcm9tKGRkYkNsaWVudCk7XG5cbmNvbnN0IFRFTEVNRVRSWV9UQUJMRSA9IHByb2Nlc3MuZW52LlRFTEVNRVRSWV9UQUJMRSE7XG5cbmV4cG9ydCBjb25zdCBoYW5kbGVyID0gYXN5bmMgKGV2ZW50OiBBUElHYXRld2F5UHJveHlFdmVudCk6IFByb21pc2U8QVBJR2F0ZXdheVByb3h5UmVzdWx0PiA9PiB7XG4gIGNvbnNvbGUubG9nKCdSZXF1ZXN0OicsIEpTT04uc3RyaW5naWZ5KGV2ZW50KSk7XG5cbiAgY29uc3QgY29yc0hlYWRlcnMgPSB7XG4gICAgJ0FjY2Vzcy1Db250cm9sLUFsbG93LU9yaWdpbic6ICcqJyxcbiAgICAnQWNjZXNzLUNvbnRyb2wtQWxsb3ctSGVhZGVycyc6ICdDb250ZW50LVR5cGUsQXV0aG9yaXphdGlvbicsXG4gICAgJ0FjY2Vzcy1Db250cm9sLUFsbG93LU1ldGhvZHMnOiAnR0VULE9QVElPTlMnLFxuICB9O1xuXG4gIHRyeSB7XG4gICAgLy8gSFRUUCBBUEkgdjIgdXNlcyByZXF1ZXN0Q29udGV4dC5odHRwLm1ldGhvZCwgUkVTVCBBUEkgdjEgdXNlcyBodHRwTWV0aG9kXG4gICAgY29uc3QgbWV0aG9kID0gKGV2ZW50LnJlcXVlc3RDb250ZXh0IGFzIGFueSk/Lmh0dHA/Lm1ldGhvZCB8fCBldmVudC5odHRwTWV0aG9kO1xuICAgIGNvbnN0IHBhdGggPSAoZXZlbnQucmVxdWVzdENvbnRleHQgYXMgYW55KT8uaHR0cD8ucGF0aCB8fCBldmVudC5wYXRoO1xuXG4gICAgaWYgKG1ldGhvZCA9PT0gJ09QVElPTlMnKSB7XG4gICAgICByZXR1cm4geyBzdGF0dXNDb2RlOiAyMDAsIGhlYWRlcnM6IGNvcnNIZWFkZXJzLCBib2R5OiAnJyB9O1xuICAgIH1cblxuICAgIGNvbnN0IGRldmljZVVpZCA9IGV2ZW50LnBhdGhQYXJhbWV0ZXJzPy5kZXZpY2VfdWlkO1xuICAgIGlmICghZGV2aWNlVWlkKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzdGF0dXNDb2RlOiA0MDAsXG4gICAgICAgIGhlYWRlcnM6IGNvcnNIZWFkZXJzLFxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7IGVycm9yOiAnZGV2aWNlX3VpZCByZXF1aXJlZCcgfSksXG4gICAgICB9O1xuICAgIH1cblxuICAgIGNvbnN0IHF1ZXJ5UGFyYW1zID0gZXZlbnQucXVlcnlTdHJpbmdQYXJhbWV0ZXJzIHx8IHt9O1xuXG4gICAgLy8gUGFyc2UgdGltZSByYW5nZVxuICAgIGNvbnN0IGhvdXJzID0gcGFyc2VJbnQocXVlcnlQYXJhbXMuaG91cnMgfHwgJzI0Jyk7XG4gICAgY29uc3QgbGltaXQgPSBwYXJzZUludChxdWVyeVBhcmFtcy5saW1pdCB8fCAnMTAwMCcpO1xuXG4gICAgaWYgKHBhdGguZW5kc1dpdGgoJy9sb2NhdGlvbicpKSB7XG4gICAgICByZXR1cm4gYXdhaXQgZ2V0TG9jYXRpb25IaXN0b3J5KGRldmljZVVpZCwgaG91cnMsIGxpbWl0LCBjb3JzSGVhZGVycyk7XG4gICAgfVxuXG4gICAgaWYgKHBhdGguZW5kc1dpdGgoJy9wb3dlcicpKSB7XG4gICAgICByZXR1cm4gYXdhaXQgZ2V0UG93ZXJIaXN0b3J5KGRldmljZVVpZCwgaG91cnMsIGxpbWl0LCBjb3JzSGVhZGVycyk7XG4gICAgfVxuXG4gICAgaWYgKHBhdGguZW5kc1dpdGgoJy9oZWFsdGgnKSkge1xuICAgICAgcmV0dXJuIGF3YWl0IGdldEhlYWx0aEhpc3RvcnkoZGV2aWNlVWlkLCBob3VycywgbGltaXQsIGNvcnNIZWFkZXJzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYXdhaXQgZ2V0VGVsZW1ldHJ5SGlzdG9yeShkZXZpY2VVaWQsIGhvdXJzLCBsaW1pdCwgY29yc0hlYWRlcnMpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yOicsIGVycm9yKTtcbiAgICByZXR1cm4ge1xuICAgICAgc3RhdHVzQ29kZTogNTAwLFxuICAgICAgaGVhZGVyczogY29yc0hlYWRlcnMsXG4gICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7IGVycm9yOiAnSW50ZXJuYWwgc2VydmVyIGVycm9yJyB9KSxcbiAgICB9O1xuICB9XG59O1xuXG5hc3luYyBmdW5jdGlvbiBnZXRUZWxlbWV0cnlIaXN0b3J5KFxuICBkZXZpY2VVaWQ6IHN0cmluZyxcbiAgaG91cnM6IG51bWJlcixcbiAgbGltaXQ6IG51bWJlcixcbiAgaGVhZGVyczogUmVjb3JkPHN0cmluZywgc3RyaW5nPlxuKTogUHJvbWlzZTxBUElHYXRld2F5UHJveHlSZXN1bHQ+IHtcbiAgY29uc3QgY3V0b2ZmVGltZSA9IERhdGUubm93KCkgLSAoaG91cnMgKiA2MCAqIDYwICogMTAwMCk7XG5cbiAgLy8gVXNlIHRoZSBldmVudC10eXBlLWluZGV4IEdTSSB0byBlZmZpY2llbnRseSBxdWVyeSBieSBkYXRhX3R5cGVcbiAgLy8gVGhlIHNvcnQga2V5IGlzIGZvcm1hdHRlZCBhcyB7ZGF0YV90eXBlfSN7dGltZXN0YW1wfVxuICBjb25zdCBjdXRvZmZLZXkgPSBgdGVsZW1ldHJ5IyR7Y3V0b2ZmVGltZX1gO1xuICBjb25zdCBlbmRLZXkgPSBgdGVsZW1ldHJ5IyR7RGF0ZS5ub3coKSArIDEwMDB9YDsgLy8gU2xpZ2h0bHkgaW4gZnV0dXJlIHRvIGluY2x1ZGUgbGF0ZXN0XG5cbiAgY29uc3QgY29tbWFuZCA9IG5ldyBRdWVyeUNvbW1hbmQoe1xuICAgIFRhYmxlTmFtZTogVEVMRU1FVFJZX1RBQkxFLFxuICAgIEluZGV4TmFtZTogJ2V2ZW50LXR5cGUtaW5kZXgnLFxuICAgIEtleUNvbmRpdGlvbkV4cHJlc3Npb246ICdkZXZpY2VfdWlkID0gOmRldmljZV91aWQgQU5EIGV2ZW50X3R5cGVfdGltZXN0YW1wIEJFVFdFRU4gOnN0YXJ0IEFORCA6ZW5kJyxcbiAgICBFeHByZXNzaW9uQXR0cmlidXRlVmFsdWVzOiB7XG4gICAgICAnOmRldmljZV91aWQnOiBkZXZpY2VVaWQsXG4gICAgICAnOnN0YXJ0JzogY3V0b2ZmS2V5LFxuICAgICAgJzplbmQnOiBlbmRLZXksXG4gICAgfSxcbiAgICBTY2FuSW5kZXhGb3J3YXJkOiBmYWxzZSwgLy8gTmV3ZXN0IGZpcnN0XG4gICAgTGltaXQ6IGxpbWl0LFxuICB9KTtcblxuICBjb25zdCByZXN1bHQgPSBhd2FpdCBkb2NDbGllbnQuc2VuZChjb21tYW5kKTtcblxuICAvLyBUcmFuc2Zvcm0gdG8gQVBJIHJlc3BvbnNlIGZvcm1hdFxuICBjb25zdCB0ZWxlbWV0cnkgPSAocmVzdWx0Lkl0ZW1zIHx8IFtdKS5tYXAoKGl0ZW0pID0+ICh7XG4gICAgdGltZTogbmV3IERhdGUoaXRlbS50aW1lc3RhbXApLnRvSVNPU3RyaW5nKCksXG4gICAgdGVtcGVyYXR1cmU6IGl0ZW0udGVtcGVyYXR1cmUsXG4gICAgaHVtaWRpdHk6IGl0ZW0uaHVtaWRpdHksXG4gICAgcHJlc3N1cmU6IGl0ZW0ucHJlc3N1cmUsXG4gICAgdm9sdGFnZTogaXRlbS52b2x0YWdlLFxuICAgIG1vdGlvbjogaXRlbS5tb3Rpb24sXG4gIH0pKTtcblxuICByZXR1cm4ge1xuICAgIHN0YXR1c0NvZGU6IDIwMCxcbiAgICBoZWFkZXJzLFxuICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgIGRldmljZV91aWQ6IGRldmljZVVpZCxcbiAgICAgIGhvdXJzLFxuICAgICAgY291bnQ6IHRlbGVtZXRyeS5sZW5ndGgsXG4gICAgICB0ZWxlbWV0cnksXG4gICAgfSksXG4gIH07XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGdldExvY2F0aW9uSGlzdG9yeShcbiAgZGV2aWNlVWlkOiBzdHJpbmcsXG4gIGhvdXJzOiBudW1iZXIsXG4gIGxpbWl0OiBudW1iZXIsXG4gIGhlYWRlcnM6IFJlY29yZDxzdHJpbmcsIHN0cmluZz5cbik6IFByb21pc2U8QVBJR2F0ZXdheVByb3h5UmVzdWx0PiB7XG4gIGNvbnN0IGN1dG9mZlRpbWUgPSBEYXRlLm5vdygpIC0gKGhvdXJzICogNjAgKiA2MCAqIDEwMDApO1xuXG4gIC8vIFVzZSB0aGUgZXZlbnQtdHlwZS1pbmRleCBHU0kgdG8gZWZmaWNpZW50bHkgcXVlcnkgdGVsZW1ldHJ5IHJlY29yZHNcbiAgY29uc3QgY3V0b2ZmS2V5ID0gYHRlbGVtZXRyeSMke2N1dG9mZlRpbWV9YDtcbiAgY29uc3QgZW5kS2V5ID0gYHRlbGVtZXRyeSMke0RhdGUubm93KCkgKyAxMDAwfWA7XG5cbiAgY29uc3QgY29tbWFuZCA9IG5ldyBRdWVyeUNvbW1hbmQoe1xuICAgIFRhYmxlTmFtZTogVEVMRU1FVFJZX1RBQkxFLFxuICAgIEluZGV4TmFtZTogJ2V2ZW50LXR5cGUtaW5kZXgnLFxuICAgIEtleUNvbmRpdGlvbkV4cHJlc3Npb246ICdkZXZpY2VfdWlkID0gOmRldmljZV91aWQgQU5EIGV2ZW50X3R5cGVfdGltZXN0YW1wIEJFVFdFRU4gOnN0YXJ0IEFORCA6ZW5kJyxcbiAgICBGaWx0ZXJFeHByZXNzaW9uOiAnYXR0cmlidXRlX2V4aXN0cyhsYXRpdHVkZSknLFxuICAgIEV4cHJlc3Npb25BdHRyaWJ1dGVWYWx1ZXM6IHtcbiAgICAgICc6ZGV2aWNlX3VpZCc6IGRldmljZVVpZCxcbiAgICAgICc6c3RhcnQnOiBjdXRvZmZLZXksXG4gICAgICAnOmVuZCc6IGVuZEtleSxcbiAgICB9LFxuICAgIFNjYW5JbmRleEZvcndhcmQ6IGZhbHNlLCAvLyBOZXdlc3QgZmlyc3RcbiAgICBMaW1pdDogbGltaXQsXG4gIH0pO1xuXG4gIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGRvY0NsaWVudC5zZW5kKGNvbW1hbmQpO1xuXG4gIC8vIFRyYW5zZm9ybSB0byBBUEkgcmVzcG9uc2UgZm9ybWF0XG4gIGNvbnN0IGxvY2F0aW9ucyA9IChyZXN1bHQuSXRlbXMgfHwgW10pXG4gICAgLmZpbHRlcigoaXRlbSkgPT4gaXRlbS5sYXRpdHVkZSAhPT0gdW5kZWZpbmVkICYmIGl0ZW0ubG9uZ2l0dWRlICE9PSB1bmRlZmluZWQpXG4gICAgLm1hcCgoaXRlbSkgPT4gKHtcbiAgICAgIHRpbWU6IG5ldyBEYXRlKGl0ZW0udGltZXN0YW1wKS50b0lTT1N0cmluZygpLFxuICAgICAgbGF0OiBpdGVtLmxhdGl0dWRlLFxuICAgICAgbG9uOiBpdGVtLmxvbmdpdHVkZSxcbiAgICAgIHNvdXJjZTogaXRlbS5sb2NhdGlvbl9zb3VyY2UsXG4gICAgfSkpO1xuXG4gIHJldHVybiB7XG4gICAgc3RhdHVzQ29kZTogMjAwLFxuICAgIGhlYWRlcnMsXG4gICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgZGV2aWNlX3VpZDogZGV2aWNlVWlkLFxuICAgICAgaG91cnMsXG4gICAgICBjb3VudDogbG9jYXRpb25zLmxlbmd0aCxcbiAgICAgIGxvY2F0aW9ucyxcbiAgICB9KSxcbiAgfTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gZ2V0UG93ZXJIaXN0b3J5KFxuICBkZXZpY2VVaWQ6IHN0cmluZyxcbiAgaG91cnM6IG51bWJlcixcbiAgbGltaXQ6IG51bWJlcixcbiAgaGVhZGVyczogUmVjb3JkPHN0cmluZywgc3RyaW5nPlxuKTogUHJvbWlzZTxBUElHYXRld2F5UHJveHlSZXN1bHQ+IHtcbiAgY29uc3QgY3V0b2ZmVGltZSA9IERhdGUubm93KCkgLSAoaG91cnMgKiA2MCAqIDYwICogMTAwMCk7XG5cbiAgLy8gVXNlIHRoZSBldmVudC10eXBlLWluZGV4IEdTSSB0byBlZmZpY2llbnRseSBxdWVyeSBwb3dlciByZWNvcmRzXG4gIGNvbnN0IGN1dG9mZktleSA9IGBwb3dlciMke2N1dG9mZlRpbWV9YDtcbiAgY29uc3QgZW5kS2V5ID0gYHBvd2VyIyR7RGF0ZS5ub3coKSArIDEwMDB9YDtcblxuICBjb25zdCBjb21tYW5kID0gbmV3IFF1ZXJ5Q29tbWFuZCh7XG4gICAgVGFibGVOYW1lOiBURUxFTUVUUllfVEFCTEUsXG4gICAgSW5kZXhOYW1lOiAnZXZlbnQtdHlwZS1pbmRleCcsXG4gICAgS2V5Q29uZGl0aW9uRXhwcmVzc2lvbjogJ2RldmljZV91aWQgPSA6ZGV2aWNlX3VpZCBBTkQgZXZlbnRfdHlwZV90aW1lc3RhbXAgQkVUV0VFTiA6c3RhcnQgQU5EIDplbmQnLFxuICAgIEV4cHJlc3Npb25BdHRyaWJ1dGVWYWx1ZXM6IHtcbiAgICAgICc6ZGV2aWNlX3VpZCc6IGRldmljZVVpZCxcbiAgICAgICc6c3RhcnQnOiBjdXRvZmZLZXksXG4gICAgICAnOmVuZCc6IGVuZEtleSxcbiAgICB9LFxuICAgIFNjYW5JbmRleEZvcndhcmQ6IGZhbHNlLCAvLyBOZXdlc3QgZmlyc3RcbiAgICBMaW1pdDogbGltaXQsXG4gIH0pO1xuXG4gIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGRvY0NsaWVudC5zZW5kKGNvbW1hbmQpO1xuXG4gIC8vIFRyYW5zZm9ybSB0byBBUEkgcmVzcG9uc2UgZm9ybWF0XG4gIGNvbnN0IHBvd2VyID0gKHJlc3VsdC5JdGVtcyB8fCBbXSkubWFwKChpdGVtKSA9PiAoe1xuICAgIHRpbWU6IG5ldyBEYXRlKGl0ZW0udGltZXN0YW1wKS50b0lTT1N0cmluZygpLFxuICAgIHZvbHRhZ2U6IGl0ZW0ubW9qb192b2x0YWdlLFxuICAgIG1pbGxpYW1wX2hvdXJzOiBpdGVtLm1pbGxpYW1wX2hvdXJzLFxuICB9KSk7XG5cbiAgcmV0dXJuIHtcbiAgICBzdGF0dXNDb2RlOiAyMDAsXG4gICAgaGVhZGVycyxcbiAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICBkZXZpY2VfdWlkOiBkZXZpY2VVaWQsXG4gICAgICBob3VycyxcbiAgICAgIGNvdW50OiBwb3dlci5sZW5ndGgsXG4gICAgICBwb3dlcixcbiAgICB9KSxcbiAgfTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gZ2V0SGVhbHRoSGlzdG9yeShcbiAgZGV2aWNlVWlkOiBzdHJpbmcsXG4gIGhvdXJzOiBudW1iZXIsXG4gIGxpbWl0OiBudW1iZXIsXG4gIGhlYWRlcnM6IFJlY29yZDxzdHJpbmcsIHN0cmluZz5cbik6IFByb21pc2U8QVBJR2F0ZXdheVByb3h5UmVzdWx0PiB7XG4gIGNvbnN0IGN1dG9mZlRpbWUgPSBEYXRlLm5vdygpIC0gKGhvdXJzICogNjAgKiA2MCAqIDEwMDApO1xuXG4gIC8vIFVzZSB0aGUgZXZlbnQtdHlwZS1pbmRleCBHU0kgdG8gZWZmaWNpZW50bHkgcXVlcnkgaGVhbHRoIHJlY29yZHNcbiAgY29uc3QgY3V0b2ZmS2V5ID0gYGhlYWx0aCMke2N1dG9mZlRpbWV9YDtcbiAgY29uc3QgZW5kS2V5ID0gYGhlYWx0aCMke0RhdGUubm93KCkgKyAxMDAwfWA7XG5cbiAgY29uc3QgY29tbWFuZCA9IG5ldyBRdWVyeUNvbW1hbmQoe1xuICAgIFRhYmxlTmFtZTogVEVMRU1FVFJZX1RBQkxFLFxuICAgIEluZGV4TmFtZTogJ2V2ZW50LXR5cGUtaW5kZXgnLFxuICAgIEtleUNvbmRpdGlvbkV4cHJlc3Npb246ICdkZXZpY2VfdWlkID0gOmRldmljZV91aWQgQU5EIGV2ZW50X3R5cGVfdGltZXN0YW1wIEJFVFdFRU4gOnN0YXJ0IEFORCA6ZW5kJyxcbiAgICBFeHByZXNzaW9uQXR0cmlidXRlVmFsdWVzOiB7XG4gICAgICAnOmRldmljZV91aWQnOiBkZXZpY2VVaWQsXG4gICAgICAnOnN0YXJ0JzogY3V0b2ZmS2V5LFxuICAgICAgJzplbmQnOiBlbmRLZXksXG4gICAgfSxcbiAgICBTY2FuSW5kZXhGb3J3YXJkOiBmYWxzZSwgLy8gTmV3ZXN0IGZpcnN0XG4gICAgTGltaXQ6IGxpbWl0LFxuICB9KTtcblxuICBjb25zdCByZXN1bHQgPSBhd2FpdCBkb2NDbGllbnQuc2VuZChjb21tYW5kKTtcblxuICAvLyBUcmFuc2Zvcm0gdG8gQVBJIHJlc3BvbnNlIGZvcm1hdFxuICBjb25zdCBoZWFsdGggPSAocmVzdWx0Lkl0ZW1zIHx8IFtdKS5tYXAoKGl0ZW0pID0+ICh7XG4gICAgdGltZTogbmV3IERhdGUoaXRlbS50aW1lc3RhbXApLnRvSVNPU3RyaW5nKCksXG4gICAgbWV0aG9kOiBpdGVtLm1ldGhvZCxcbiAgICB0ZXh0OiBpdGVtLnRleHQsXG4gICAgdm9sdGFnZTogaXRlbS52b2x0YWdlLFxuICAgIHZvbHRhZ2VfbW9kZTogaXRlbS52b2x0YWdlX21vZGUsXG4gICAgbWlsbGlhbXBfaG91cnM6IGl0ZW0ubWlsbGlhbXBfaG91cnMsXG4gIH0pKTtcblxuICByZXR1cm4ge1xuICAgIHN0YXR1c0NvZGU6IDIwMCxcbiAgICBoZWFkZXJzLFxuICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgIGRldmljZV91aWQ6IGRldmljZVVpZCxcbiAgICAgIGhvdXJzLFxuICAgICAgY291bnQ6IGhlYWx0aC5sZW5ndGgsXG4gICAgICBoZWFsdGgsXG4gICAgfSksXG4gIH07XG59XG4iXX0=