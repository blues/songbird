"use strict";
/**
 * Telemetry API Lambda
 *
 * Queries DynamoDB for device telemetry data:
 * - GET /devices/{device_uid}/telemetry - Get telemetry history
 * - GET /devices/{device_uid}/location - Get location history
 * - GET /devices/{device_uid}/power - Get Mojo power history
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.handler = void 0;
const client_dynamodb_1 = require("@aws-sdk/client-dynamodb");
const lib_dynamodb_1 = require("@aws-sdk/lib-dynamodb");
const ddbClient = new client_dynamodb_1.DynamoDBClient({});
const docClient = lib_dynamodb_1.DynamoDBDocumentClient.from(ddbClient);
const TELEMETRY_TABLE = process.env.TELEMETRY_TABLE;
const handler = async (event) => {
    console.log('Request:', JSON.stringify(event));
    const corsHeaders = {
        'Access-Control-Allow-Origin': '*',
        'Access-Control-Allow-Headers': 'Content-Type,Authorization',
        'Access-Control-Allow-Methods': 'GET,OPTIONS',
    };
    try {
        if (event.httpMethod === 'OPTIONS') {
            return { statusCode: 200, headers: corsHeaders, body: '' };
        }
        const deviceUid = event.pathParameters?.device_uid;
        if (!deviceUid) {
            return {
                statusCode: 400,
                headers: corsHeaders,
                body: JSON.stringify({ error: 'device_uid required' }),
            };
        }
        const path = event.path;
        const queryParams = event.queryStringParameters || {};
        // Parse time range
        const hours = parseInt(queryParams.hours || '24');
        const limit = parseInt(queryParams.limit || '1000');
        if (path.endsWith('/location')) {
            return await getLocationHistory(deviceUid, hours, limit, corsHeaders);
        }
        if (path.endsWith('/power')) {
            return await getPowerHistory(deviceUid, hours, limit, corsHeaders);
        }
        return await getTelemetryHistory(deviceUid, hours, limit, corsHeaders);
    }
    catch (error) {
        console.error('Error:', error);
        return {
            statusCode: 500,
            headers: corsHeaders,
            body: JSON.stringify({ error: 'Internal server error' }),
        };
    }
};
exports.handler = handler;
async function getTelemetryHistory(deviceUid, hours, limit, headers) {
    const cutoffTime = Date.now() - (hours * 60 * 60 * 1000);
    const command = new lib_dynamodb_1.QueryCommand({
        TableName: TELEMETRY_TABLE,
        KeyConditionExpression: 'device_uid = :device_uid AND #ts > :cutoff',
        FilterExpression: 'data_type = :data_type',
        ExpressionAttributeNames: {
            '#ts': 'timestamp',
        },
        ExpressionAttributeValues: {
            ':device_uid': deviceUid,
            ':cutoff': cutoffTime,
            ':data_type': 'telemetry',
        },
        ScanIndexForward: false, // Newest first
        Limit: limit,
    });
    const result = await docClient.send(command);
    // Transform to API response format
    const telemetry = (result.Items || []).map((item) => ({
        time: new Date(item.timestamp).toISOString(),
        temperature: item.temperature,
        humidity: item.humidity,
        pressure: item.pressure,
        voltage: item.voltage,
        motion: item.motion,
    }));
    return {
        statusCode: 200,
        headers,
        body: JSON.stringify({
            device_uid: deviceUid,
            hours,
            count: telemetry.length,
            telemetry,
        }),
    };
}
async function getLocationHistory(deviceUid, hours, limit, headers) {
    const cutoffTime = Date.now() - (hours * 60 * 60 * 1000);
    const command = new lib_dynamodb_1.QueryCommand({
        TableName: TELEMETRY_TABLE,
        KeyConditionExpression: 'device_uid = :device_uid AND #ts > :cutoff',
        FilterExpression: 'data_type = :data_type AND attribute_exists(latitude)',
        ExpressionAttributeNames: {
            '#ts': 'timestamp',
        },
        ExpressionAttributeValues: {
            ':device_uid': deviceUid,
            ':cutoff': cutoffTime,
            ':data_type': 'telemetry',
        },
        ScanIndexForward: false, // Newest first
        Limit: limit,
    });
    const result = await docClient.send(command);
    // Transform to API response format
    const locations = (result.Items || [])
        .filter((item) => item.latitude !== undefined && item.longitude !== undefined)
        .map((item) => ({
        time: new Date(item.timestamp).toISOString(),
        lat: item.latitude,
        lon: item.longitude,
    }));
    return {
        statusCode: 200,
        headers,
        body: JSON.stringify({
            device_uid: deviceUid,
            hours,
            count: locations.length,
            locations,
        }),
    };
}
async function getPowerHistory(deviceUid, hours, limit, headers) {
    const cutoffTime = Date.now() - (hours * 60 * 60 * 1000);
    const command = new lib_dynamodb_1.QueryCommand({
        TableName: TELEMETRY_TABLE,
        KeyConditionExpression: 'device_uid = :device_uid AND #ts > :cutoff',
        FilterExpression: 'data_type = :data_type',
        ExpressionAttributeNames: {
            '#ts': 'timestamp',
        },
        ExpressionAttributeValues: {
            ':device_uid': deviceUid,
            ':cutoff': cutoffTime,
            ':data_type': 'power',
        },
        ScanIndexForward: false, // Newest first
        Limit: limit,
    });
    const result = await docClient.send(command);
    // Transform to API response format
    const power = (result.Items || []).map((item) => ({
        time: new Date(item.timestamp).toISOString(),
        voltage: item.mojo_voltage,
        temperature: item.mojo_temperature,
        milliamp_hours: item.milliamp_hours,
    }));
    return {
        statusCode: 200,
        headers,
        body: JSON.stringify({
            device_uid: deviceUid,
            hours,
            count: power.length,
            power,
        }),
    };
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi9sYW1iZGEvYXBpLXRlbGVtZXRyeS9pbmRleC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUE7Ozs7Ozs7R0FPRzs7O0FBRUgsOERBQTBEO0FBQzFELHdEQUE2RTtBQUc3RSxNQUFNLFNBQVMsR0FBRyxJQUFJLGdDQUFjLENBQUMsRUFBRSxDQUFDLENBQUM7QUFDekMsTUFBTSxTQUFTLEdBQUcscUNBQXNCLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDO0FBRXpELE1BQU0sZUFBZSxHQUFHLE9BQU8sQ0FBQyxHQUFHLENBQUMsZUFBZ0IsQ0FBQztBQUU5QyxNQUFNLE9BQU8sR0FBRyxLQUFLLEVBQUUsS0FBMkIsRUFBa0MsRUFBRTtJQUMzRixPQUFPLENBQUMsR0FBRyxDQUFDLFVBQVUsRUFBRSxJQUFJLENBQUMsU0FBUyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUM7SUFFL0MsTUFBTSxXQUFXLEdBQUc7UUFDbEIsNkJBQTZCLEVBQUUsR0FBRztRQUNsQyw4QkFBOEIsRUFBRSw0QkFBNEI7UUFDNUQsOEJBQThCLEVBQUUsYUFBYTtLQUM5QyxDQUFDO0lBRUYsSUFBSSxDQUFDO1FBQ0gsSUFBSSxLQUFLLENBQUMsVUFBVSxLQUFLLFNBQVMsRUFBRSxDQUFDO1lBQ25DLE9BQU8sRUFBRSxVQUFVLEVBQUUsR0FBRyxFQUFFLE9BQU8sRUFBRSxXQUFXLEVBQUUsSUFBSSxFQUFFLEVBQUUsRUFBRSxDQUFDO1FBQzdELENBQUM7UUFFRCxNQUFNLFNBQVMsR0FBRyxLQUFLLENBQUMsY0FBYyxFQUFFLFVBQVUsQ0FBQztRQUNuRCxJQUFJLENBQUMsU0FBUyxFQUFFLENBQUM7WUFDZixPQUFPO2dCQUNMLFVBQVUsRUFBRSxHQUFHO2dCQUNmLE9BQU8sRUFBRSxXQUFXO2dCQUNwQixJQUFJLEVBQUUsSUFBSSxDQUFDLFNBQVMsQ0FBQyxFQUFFLEtBQUssRUFBRSxxQkFBcUIs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QyxDQUFDLEdBQUcsQ0FBQyxDQUFDLElBQUksRUFBRSxFQUFFLENBQUMsQ0FBQztRQUNoRCxJQUFJLEVBQUUsSUFBSSxJQUFJLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDLFdBQVcsRUFBRTtRQUM1QyxPQUFPLEVBQUUsSUFBSSxDQUFDLFlBQVk7UUFDMUIsV0FBVyxFQUFFLElBQUksQ0FBQyxnQkFBZ0I7UUFDbEMsY0FBYyxFQUFFLElBQUksQ0FBQyxjQUFjO0tBQ3BDLENBQUMsQ0FBQyxDQUFDO0lBRUosT0FBTztRQUNMLFVBQVUsRUFBRSxHQUFHO1FBQ2YsT0FBTztRQUNQLElBQUksRUFBRSxJQUFJLENBQUMsU0FBUyxDQUFDO1lBQ25CLFVBQVUsRUFBRSxTQUFTO1lBQ3JCLEtBQUs7WUFDTCxLQUFLLEVBQUUsS0FBSyxDQUFDLE1BQU07WUFDbkIsS0FBSztTQUNOLENBQUM7S0FDSCxDQUFDO0FBQ0osQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogVGVsZW1ldHJ5IEFQSSBMYW1iZGFcbiAqXG4gKiBRdWVyaWVzIER5bmFtb0RCIGZvciBkZXZpY2UgdGVsZW1ldHJ5IGRhdGE6XG4gKiAtIEdFVCAvZGV2aWNlcy97ZGV2aWNlX3VpZH0vdGVsZW1ldHJ5IC0gR2V0IHRlbGVtZXRyeSBoaXN0b3J5XG4gKiAtIEdFVCAvZGV2aWNlcy97ZGV2aWNlX3VpZH0vbG9jYXRpb24gLSBHZXQgbG9jYXRpb24gaGlzdG9yeVxuICogLSBHRVQgL2RldmljZXMve2RldmljZV91aWR9L3Bvd2VyIC0gR2V0IE1vam8gcG93ZXIgaGlzdG9yeVxuICovXG5cbmltcG9ydCB7IER5bmFtb0RCQ2xpZW50IH0gZnJvbSAnQGF3cy1zZGsvY2xpZW50LWR5bmFtb2RiJztcbmltcG9ydCB7IER5bmFtb0RCRG9jdW1lbnRDbGllbnQsIFF1ZXJ5Q29tbWFuZCB9IGZyb20gJ0Bhd3Mtc2RrL2xpYi1keW5hbW9kYic7XG5pbXBvcnQgeyBBUElHYXRld2F5UHJveHlFdmVudCwgQVBJR2F0ZXdheVByb3h5UmVzdWx0IH0gZnJvbSAnYXdzLWxhbWJkYSc7XG5cbmNvbnN0IGRkYkNsaWVudCA9IG5ldyBEeW5hbW9EQkNsaWVudCh7fSk7XG5jb25zdCBkb2NDbGllbnQgPSBEeW5hbW9EQkRvY3VtZW50Q2xpZW50LmZyb20oZGRiQ2xpZW50KTtcblxuY29uc3QgVEVMRU1FVFJZX1RBQkxFID0gcHJvY2Vzcy5lbnYuVEVMRU1FVFJZX1RBQkxFITtcblxuZXhwb3J0IGNvbnN0IGhhbmRsZXIgPSBhc3luYyAoZXZlbnQ6IEFQSUdhdGV3YXlQcm94eUV2ZW50KTogUHJvbWlzZTxBUElHYXRld2F5UHJveHlSZXN1bHQ+ID0+IHtcbiAgY29uc29sZS5sb2coJ1JlcXVlc3Q6JywgSlNPTi5zdHJpbmdpZnkoZXZlbnQpKTtcblxuICBjb25zdCBjb3JzSGVhZGVycyA9IHtcbiAgICAnQWNjZXNzLUNvbnRyb2wtQWxsb3ctT3JpZ2luJzogJyonLFxuICAgICdBY2Nlc3MtQ29udHJvbC1BbGxvdy1IZWFkZXJzJzogJ0NvbnRlbnQtVHlwZSxBdXRob3JpemF0aW9uJyxcbiAgICAnQWNjZXNzLUNvbnRyb2wtQWxsb3ctTWV0aG9kcyc6ICdHRVQsT1BUSU9OUycsXG4gIH07XG5cbiAgdHJ5IHtcbiAgICBpZiAoZXZlbnQuaHR0cE1ldGhvZCA9PT0gJ09QVElPTlMnKSB7XG4gICAgICByZXR1cm4geyBzdGF0dXNDb2RlOiAyMDAsIGhlYWRlcnM6IGNvcnNIZWFkZXJzLCBib2R5OiAnJyB9O1xuICAgIH1cblxuICAgIGNvbnN0IGRldmljZVVpZCA9IGV2ZW50LnBhdGhQYXJhbWV0ZXJzPy5kZXZpY2VfdWlkO1xuICAgIGlmICghZGV2aWNlVWlkKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzdGF0dXNDb2RlOiA0MDAsXG4gICAgICAgIGhlYWRlcnM6IGNvcnNIZWFkZXJzLFxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7IGVycm9yOiAnZGV2aWNlX3VpZCByZXF1aXJlZCcgfSksXG4gICAgICB9O1xuICAgIH1cblxuICAgIGNvbnN0IHBhdGggPSBldmVudC5wYXRoO1xuICAgIGNvbnN0IHF1ZXJ5UGFyYW1zID0gZXZlbnQucXVlcnlTdHJpbmdQYXJhbWV0ZXJzIHx8IHt9O1xuXG4gICAgLy8gUGFyc2UgdGltZSByYW5nZVxuICAgIGNvbnN0IGhvdXJzID0gcGFyc2VJbnQocXVlcnlQYXJhbXMuaG91cnMgfHwgJzI0Jyk7XG4gICAgY29uc3QgbGltaXQgPSBwYXJzZUludChxdWVyeVBhcmFtcy5saW1pdCB8fCAnMTAwMCcpO1xuXG4gICAgaWYgKHBhdGguZW5kc1dpdGgoJy9sb2NhdGlvbicpKSB7XG4gICAgICByZXR1cm4gYXdhaXQgZ2V0TG9jYXRpb25IaXN0b3J5KGRldmljZVVpZCwgaG91cnMsIGxpbWl0LCBjb3JzSGVhZGVycyk7XG4gICAgfVxuXG4gICAgaWYgKHBhdGguZW5kc1dpdGgoJy9wb3dlcicpKSB7XG4gICAgICByZXR1cm4gYXdhaXQgZ2V0UG93ZXJIaXN0b3J5KGRldmljZVVpZCwgaG91cnMsIGxpbWl0LCBjb3JzSGVhZGVycyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGF3YWl0IGdldFRlbGVtZXRyeUhpc3RvcnkoZGV2aWNlVWlkLCBob3VycywgbGltaXQsIGNvcnNIZWFkZXJzKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvcjonLCBlcnJvcik7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN0YXR1c0NvZGU6IDUwMCxcbiAgICAgIGhlYWRlcnM6IGNvcnNIZWFkZXJzLFxuICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoeyBlcnJvcjogJ0ludGVybmFsIHNlcnZlciBlcnJvcicgfSksXG4gICAgfTtcbiAgfVxufTtcblxuYXN5bmMgZnVuY3Rpb24gZ2V0VGVsZW1ldHJ5SGlzdG9yeShcbiAgZGV2aWNlVWlkOiBzdHJpbmcsXG4gIGhvdXJzOiBudW1iZXIsXG4gIGxpbWl0OiBudW1iZXIsXG4gIGhlYWRlcnM6IFJlY29yZDxzdHJpbmcsIHN0cmluZz5cbik6IFByb21pc2U8QVBJR2F0ZXdheVByb3h5UmVzdWx0PiB7XG4gIGNvbnN0IGN1dG9mZlRpbWUgPSBEYXRlLm5vdygpIC0gKGhvdXJzICogNjAgKiA2MCAqIDEwMDApO1xuXG4gIGNvbnN0IGNvbW1hbmQgPSBuZXcgUXVlcnlDb21tYW5kKHtcbiAgICBUYWJsZU5hbWU6IFRFTEVNRVRSWV9UQUJMRSxcbiAgICBLZXlDb25kaXRpb25FeHByZXNzaW9uOiAnZGV2aWNlX3VpZCA9IDpkZXZpY2VfdWlkIEFORCAjdHMgPiA6Y3V0b2ZmJyxcbiAgICBGaWx0ZXJFeHByZXNzaW9uOiAnZGF0YV90eXBlID0gOmRhdGFfdHlwZScsXG4gICAgRXhwcmVzc2lvbkF0dHJpYnV0ZU5hbWVzOiB7XG4gICAgICAnI3RzJzogJ3RpbWVzdGFtcCcsXG4gICAgfSxcbiAgICBFeHByZXNzaW9uQXR0cmlidXRlVmFsdWVzOiB7XG4gICAgICAnOmRldmljZV91aWQnOiBkZXZpY2VVaWQsXG4gICAgICAnOmN1dG9mZic6IGN1dG9mZlRpbWUsXG4gICAgICAnOmRhdGFfdHlwZSc6ICd0ZWxlbWV0cnknLFxuICAgIH0sXG4gICAgU2NhbkluZGV4Rm9yd2FyZDogZmFsc2UsIC8vIE5ld2VzdCBmaXJzdFxuICAgIExpbWl0OiBsaW1pdCxcbiAgfSk7XG5cbiAgY29uc3QgcmVzdWx0ID0gYXdhaXQgZG9jQ2xpZW50LnNlbmQoY29tbWFuZCk7XG5cbiAgLy8gVHJhbnNmb3JtIHRvIEFQSSByZXNwb25zZSBmb3JtYXRcbiAgY29uc3QgdGVsZW1ldHJ5ID0gKHJlc3VsdC5JdGVtcyB8fCBbXSkubWFwKChpdGVtKSA9PiAoe1xuICAgIHRpbWU6IG5ldyBEYXRlKGl0ZW0udGltZXN0YW1wKS50b0lTT1N0cmluZygpLFxuICAgIHRlbXBlcmF0dXJlOiBpdGVtLnRlbXBlcmF0dXJlLFxuICAgIGh1bWlkaXR5OiBpdGVtLmh1bWlkaXR5LFxuICAgIHByZXNzdXJlOiBpdGVtLnByZXNzdXJlLFxuICAgIHZvbHRhZ2U6IGl0ZW0udm9sdGFnZSxcbiAgICBtb3Rpb246IGl0ZW0ubW90aW9uLFxuICB9KSk7XG5cbiAgcmV0dXJuIHtcbiAgICBzdGF0dXNDb2RlOiAyMDAsXG4gICAgaGVhZGVycyxcbiAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICBkZXZpY2VfdWlkOiBkZXZpY2VVaWQsXG4gICAgICBob3VycyxcbiAgICAgIGNvdW50OiB0ZWxlbWV0cnkubGVuZ3RoLFxuICAgICAgdGVsZW1ldHJ5LFxuICAgIH0pLFxuICB9O1xufVxuXG5hc3luYyBmdW5jdGlvbiBnZXRMb2NhdGlvbkhpc3RvcnkoXG4gIGRldmljZVVpZDogc3RyaW5nLFxuICBob3VyczogbnVtYmVyLFxuICBsaW1pdDogbnVtYmVyLFxuICBoZWFkZXJzOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+XG4pOiBQcm9taXNlPEFQSUdhdGV3YXlQcm94eVJlc3VsdD4ge1xuICBjb25zdCBjdXRvZmZUaW1lID0gRGF0ZS5ub3coKSAtIChob3VycyAqIDYwICogNjAgKiAxMDAwKTtcblxuICBjb25zdCBjb21tYW5kID0gbmV3IFF1ZXJ5Q29tbWFuZCh7XG4gICAgVGFibGVOYW1lOiBURUxFTUVUUllfVEFCTEUsXG4gICAgS2V5Q29uZGl0aW9uRXhwcmVzc2lvbjogJ2RldmljZV91aWQgPSA6ZGV2aWNlX3VpZCBBTkQgI3RzID4gOmN1dG9mZicsXG4gICAgRmlsdGVyRXhwcmVzc2lvbjogJ2RhdGFfdHlwZSA9IDpkYXRhX3R5cGUgQU5EIGF0dHJpYnV0ZV9leGlzdHMobGF0aXR1ZGUpJyxcbiAgICBFeHByZXNzaW9uQXR0cmlidXRlTmFtZXM6IHtcbiAgICAgICcjdHMnOiAndGltZXN0YW1wJyxcbiAgICB9LFxuICAgIEV4cHJlc3Npb25BdHRyaWJ1dGVWYWx1ZXM6IHtcbiAgICAgICc6ZGV2aWNlX3VpZCc6IGRldmljZVVpZCxcbiAgICAgICc6Y3V0b2ZmJzogY3V0b2ZmVGltZSxcbiAgICAgICc6ZGF0YV90eXBlJzogJ3RlbGVtZXRyeScsXG4gICAgfSxcbiAgICBTY2FuSW5kZXhGb3J3YXJkOiBmYWxzZSwgLy8gTmV3ZXN0IGZpcnN0XG4gICAgTGltaXQ6IGxpbWl0LFxuICB9KTtcblxuICBjb25zdCByZXN1bHQgPSBhd2FpdCBkb2NDbGllbnQuc2VuZChjb21tYW5kKTtcblxuICAvLyBUcmFuc2Zvcm0gdG8gQVBJIHJlc3BvbnNlIGZvcm1hdFxuICBjb25zdCBsb2NhdGlvbnMgPSAocmVzdWx0Lkl0ZW1zIHx8IFtdKVxuICAgIC5maWx0ZXIoKGl0ZW0pID0+IGl0ZW0ubGF0aXR1ZGUgIT09IHVuZGVmaW5lZCAmJiBpdGVtLmxvbmdpdHVkZSAhPT0gdW5kZWZpbmVkKVxuICAgIC5tYXAoKGl0ZW0pID0+ICh7XG4gICAgICB0aW1lOiBuZXcgRGF0ZShpdGVtLnRpbWVzdGFtcCkudG9JU09TdHJpbmcoKSxcbiAgICAgIGxhdDogaXRlbS5sYXRpdHVkZSxcbiAgICAgIGxvbjogaXRlbS5sb25naXR1ZGUsXG4gICAgfSkpO1xuXG4gIHJldHVybiB7XG4gICAgc3RhdHVzQ29kZTogMjAwLFxuICAgIGhlYWRlcnMsXG4gICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgZGV2aWNlX3VpZDogZGV2aWNlVWlkLFxuICAgICAgaG91cnMsXG4gICAgICBjb3VudDogbG9jYXRpb25zLmxlbmd0aCxcbiAgICAgIGxvY2F0aW9ucyxcbiAgICB9KSxcbiAgfTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gZ2V0UG93ZXJIaXN0b3J5KFxuICBkZXZpY2VVaWQ6IHN0cmluZyxcbiAgaG91cnM6IG51bWJlcixcbiAgbGltaXQ6IG51bWJlcixcbiAgaGVhZGVyczogUmVjb3JkPHN0cmluZywgc3RyaW5nPlxuKTogUHJvbWlzZTxBUElHYXRld2F5UHJveHlSZXN1bHQ+IHtcbiAgY29uc3QgY3V0b2ZmVGltZSA9IERhdGUubm93KCkgLSAoaG91cnMgKiA2MCAqIDYwICogMTAwMCk7XG5cbiAgY29uc3QgY29tbWFuZCA9IG5ldyBRdWVyeUNvbW1hbmQoe1xuICAgIFRhYmxlTmFtZTogVEVMRU1FVFJZX1RBQkxFLFxuICAgIEtleUNvbmRpdGlvbkV4cHJlc3Npb246ICdkZXZpY2VfdWlkID0gOmRldmljZV91aWQgQU5EICN0cyA+IDpjdXRvZmYnLFxuICAgIEZpbHRlckV4cHJlc3Npb246ICdkYXRhX3R5cGUgPSA6ZGF0YV90eXBlJyxcbiAgICBFeHByZXNzaW9uQXR0cmlidXRlTmFtZXM6IHtcbiAgICAgICcjdHMnOiAndGltZXN0YW1wJyxcbiAgICB9LFxuICAgIEV4cHJlc3Npb25BdHRyaWJ1dGVWYWx1ZXM6IHtcbiAgICAgICc6ZGV2aWNlX3VpZCc6IGRldmljZVVpZCxcbiAgICAgICc6Y3V0b2ZmJzogY3V0b2ZmVGltZSxcbiAgICAgICc6ZGF0YV90eXBlJzogJ3Bvd2VyJyxcbiAgICB9LFxuICAgIFNjYW5JbmRleEZvcndhcmQ6IGZhbHNlLCAvLyBOZXdlc3QgZmlyc3RcbiAgICBMaW1pdDogbGltaXQsXG4gIH0pO1xuXG4gIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGRvY0NsaWVudC5zZW5kKGNvbW1hbmQpO1xuXG4gIC8vIFRyYW5zZm9ybSB0byBBUEkgcmVzcG9uc2UgZm9ybWF0XG4gIGNvbnN0IHBvd2VyID0gKHJlc3VsdC5JdGVtcyB8fCBbXSkubWFwKChpdGVtKSA9PiAoe1xuICAgIHRpbWU6IG5ldyBEYXRlKGl0ZW0udGltZXN0YW1wKS50b0lTT1N0cmluZygpLFxuICAgIHZvbHRhZ2U6IGl0ZW0ubW9qb192b2x0YWdlLFxuICAgIHRlbXBlcmF0dXJlOiBpdGVtLm1vam9fdGVtcGVyYXR1cmUsXG4gICAgbWlsbGlhbXBfaG91cnM6IGl0ZW0ubWlsbGlhbXBfaG91cnMsXG4gIH0pKTtcblxuICByZXR1cm4ge1xuICAgIHN0YXR1c0NvZGU6IDIwMCxcbiAgICBoZWFkZXJzLFxuICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgIGRldmljZV91aWQ6IGRldmljZVVpZCxcbiAgICAgIGhvdXJzLFxuICAgICAgY291bnQ6IHBvd2VyLmxlbmd0aCxcbiAgICAgIHBvd2VyLFxuICAgIH0pLFxuICB9O1xufVxuIl19